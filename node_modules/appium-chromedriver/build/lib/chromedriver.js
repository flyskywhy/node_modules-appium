require('source-map-support').install();

'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumBaseDriver = require('appium-base-driver');

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _appiumSupport = require('appium-support');

var _asyncbox = require('asyncbox');

var _teen_process = require('teen_process');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _install = require('./install');

var log = _appiumSupport.logger.getLogger('Chromedriver');

var DEFAULT_HOST = '127.0.0.1';
var DEFAULT_PORT = 9515;

var Chromedriver = (function (_events$EventEmitter) {
  _inherits(Chromedriver, _events$EventEmitter);

  function Chromedriver() {
    var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Chromedriver);

    var host = args.host;
    var port = args.port;
    var executable = args.executable;
    var cmdArgs = args.cmdArgs;
    var adb = args.adb;
    var verbose = args.verbose;
    var logPath = args.logPath;

    _get(Object.getPrototypeOf(Chromedriver.prototype), 'constructor', this).call(this);
    this.proxyHost = host || DEFAULT_HOST;
    this.proxyPort = port || DEFAULT_PORT;
    this.adb = adb;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.chromedriver = executable;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({ server: this.proxyHost, port: this.proxyPort });
    this.verbose = verbose;
    this.logPath = logPath;
  }

  _createClass(Chromedriver, [{
    key: 'initChromedriverPath',
    value: function initChromedriverPath() {
      var binPath;
      return _regeneratorRuntime.async(function initChromedriverPath$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.executableVerified) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return');

          case 2:
            context$2$0.t0 = this.chromedriver;

            if (context$2$0.t0) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap((0, _install.getChromedriverBinaryPath)());

          case 6:
            context$2$0.t0 = context$2$0.sent;

          case 7:
            binPath = context$2$0.t0;
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(binPath));

          case 10:
            if (context$2$0.sent) {
              context$2$0.next = 12;
              break;
            }

            throw new Error('Trying to use a chromedriver binary at the path ' + (binPath + ', but it doesn\'t exist!'));

          case 12:
            this.chromedriver = binPath;
            this.executableVerified = true;
            log.info('Set chromedriver binary as: ' + this.chromedriver);

          case 15:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'start',
    value: function start(caps) {
      var emitStartingState = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
      var args, startDetector, processIsAlive;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.capabilities = caps;
            if (emitStartingState) {
              this.changeState(Chromedriver.STATE_STARTING);
            }

            args = ["--url-base=wd/hub", '--port=' + this.proxyPort];

            if (this.adb && this.adb.adbPort) {
              args = args.concat(['--adb-port=' + this.adb.adbPort]);
            }
            if (this.cmdArgs) {
              args = args.concat(this.cmdArgs);
            }
            if (this.logPath) {
              args = args.concat(['--log-path=' + this.logPath]);
            }
            args = args.concat(['--verbose']);
            // what are the process stdout/stderr conditions wherein we know that
            // the process has started to our satisfaction?

            startDetector = function startDetector(stdout) {
              return stdout.indexOf('Starting ') === 0;
            };

            processIsAlive = false;
            context$2$0.prev = 9;
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.initChromedriverPath());

          case 12:
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(this.killAll());

          case 14:

            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(this.chromedriver, args);
            processIsAlive = true;

            // handle log output
            this.proc.on('output', function (stdout, stderr) {
              // give the output if it is requested
              if (_this.verbose) {
                if (stdout) {
                  log.debug('[STDOUT] ' + stdout.trim());
                }
                if (stderr) {
                  log.error('[STDERR] ' + stderr.trim());
                }
              } else {
                // if the cd output is not printed, find the chrome version and print
                // will get a response like
                //   DevTools response: {
                //      "Android-Package": "io.appium.sampleapp",
                //      "Browser": "Chrome/55.0.2883.91",
                //      "Protocol-Version": "1.2",
                //      "User-Agent": "...",
                //      "WebKit-Version": "537.36"
                //   }
                var match = /"Browser": "(.*)"/.exec(stdout + stderr);
                if (match) {
                  log.debug('Webview version: \'' + match[1] + '\'');
                }
              }
            });

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== Chromedriver.STATE_STOPPED && _this.state !== Chromedriver.STATE_STOPPING && _this.state !== Chromedriver.STATE_RESTARTING) {
                var msg = 'Chromedriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                log.error(msg);
                _this.changeState(Chromedriver.STATE_STOPPED);
              }
            });
            log.info('Spawning chromedriver with: ' + this.chromedriver + ' ' + ('' + args.join(' ')));
            // start subproc and wait for startDetector
            context$2$0.next = 21;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 21:
            context$2$0.next = 23;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 23:
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap(this.startSession());

          case 25:
            context$2$0.next = 35;
            break;

          case 27:
            context$2$0.prev = 27;
            context$2$0.t0 = context$2$0['catch'](9);

            this.emit(Chromedriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the chromedriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 33;
              break;
            }

            context$2$0.next = 33;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 33:

            // often the user's Chrome version is too low for the version of Chromedriver
            if (context$2$0.t0.message.indexOf('Chrome version must be') !== -1) {
              log.error('Unable to automate Chrome version because it is too old for this version of Chromedriver.');
              log.error('Please see \'https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/chromedriver.md\'');
            }
            log.errorAndThrow(context$2$0.t0);

          case 35:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[9, 27]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== Chromedriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'restart',
    value: function restart() {
      return _regeneratorRuntime.async(function restart$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            log.info("Restarting chromedriver");

            if (!(this.state !== Chromedriver.STATE_ONLINE)) {
              context$2$0.next = 3;
              break;
            }

            throw new Error("Can't restart when we're not online");

          case 3:
            this.changeState(Chromedriver.STATE_RESTARTING);
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.stop(false));

          case 6:
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.start(this.capabilities, false));

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: '_statePromise',
    value: function _statePromise() {
      var _this2 = this;

      var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      return new _bluebird2['default'](function (resolve) {
        var listener = function listener(msg) {
          if (state === null || msg.state === state) {
            resolve(msg.state);
            _this2.removeListener(Chromedriver.EVENT_CHANGED, listener);
          }
        };
        _this2.on(Chromedriver.EVENT_CHANGED, listener);
      });
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      var chromedriverStopped;
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            chromedriverStopped = false;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(20, 200, function callee$2$0() {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    if (!(this.state === Chromedriver.STATE_STOPPED)) {
                      context$3$0.next = 3;
                      break;
                    }

                    // we are either stopped or stopping, so something went wrong
                    chromedriverStopped = true;
                    return context$3$0.abrupt('return');

                  case 3:
                    context$3$0.next = 5;
                    return _regeneratorRuntime.awrap(this.getStatus());

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this3);
            }));

          case 3:
            if (!chromedriverStopped) {
              context$2$0.next = 5;
              break;
            }

            throw new Error('ChromeDriver crashed during startup.');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/status', 'GET'));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession() {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        var _this4 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(4, 200, function callee$2$0() {
              var res;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(this.jwproxy.command('/session', 'POST', { desiredCapabilities: this.capabilities }));

                  case 2:
                    res = context$3$0.sent;

                    if (!res.status) {
                      context$3$0.next = 5;
                      break;
                    }

                    throw new Error(res.value.message);

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this4);
            }));

          case 2:
            this.changeState(Chromedriver.STATE_ONLINE);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(Chromedriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('', 'DELETE'));

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 20000));

          case 6:
            if (emitStates) {
              this.changeState(Chromedriver.STATE_STOPPED);
            }
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](1);

            log.error(context$2$0.t0);

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 9]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      log.debug('Changed state to \'' + state + '\'');
      this.emit(Chromedriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, conn, params;

      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            if (_appiumSupport.system.isWindows()) {
              // js hint cannot handle backticks, even escaped, within template literals
              cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I chromedriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            } else {
              cmd = 'pkill -15 -f "' + this.chromedriver + '.*--port=' + this.proxyPort + '"';
            }
            log.debug('Killing any old chromedrivers, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            log.debug("Successfully cleaned up old chromedrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            log.warn("No old chromedrivers seemed to exist");

          case 12:
            if (!this.adb) {
              context$2$0.next = 46;
              break;
            }

            log.debug('Cleaning any old adb forwarded port socket connections');
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 17;
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.adb.getForwardList());

          case 20:
            context$2$0.t1 = _Symbol$iterator;
            _iterator = context$2$0.sent[context$2$0.t1]();

          case 22:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 32;
              break;
            }

            conn = _step.value;

            if (!(conn.indexOf('webview_devtools') !== -1)) {
              context$2$0.next = 29;
              break;
            }

            params = conn.split(/\s+/);

            if (!(params.length > 1)) {
              context$2$0.next = 29;
              break;
            }

            context$2$0.next = 29;
            return _regeneratorRuntime.awrap(this.adb.removePortForward(params[1].replace(/[\D]*/, '')));

          case 29:
            _iteratorNormalCompletion = true;
            context$2$0.next = 22;
            break;

          case 32:
            context$2$0.next = 38;
            break;

          case 34:
            context$2$0.prev = 34;
            context$2$0.t2 = context$2$0['catch'](17);
            _didIteratorError = true;
            _iteratorError = context$2$0.t2;

          case 38:
            context$2$0.prev = 38;
            context$2$0.prev = 39;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 41:
            context$2$0.prev = 41;

            if (!_didIteratorError) {
              context$2$0.next = 44;
              break;
            }

            throw _iteratorError;

          case 44:
            return context$2$0.finish(41);

          case 45:
            return context$2$0.finish(38);

          case 46:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9], [17, 34, 38, 46], [39,, 41, 45]]);
    }
  }, {
    key: 'hasWorkingWebview',
    value: function hasWorkingWebview() {
      return _regeneratorRuntime.async(function hasWorkingWebview$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/url', 'GET'));

          case 3:
            return context$2$0.abrupt('return', true);

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](0);
            return context$2$0.abrupt('return', false);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 6]]);
    }
  }]);

  return Chromedriver;
})(_events2['default'].EventEmitter);

Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';

exports['default'] = Chromedriver;
module.exports = exports['default'];
//eslint-disable-line curly

// we need to make sure that CD hasn't crashed

// retry session start 4 times, sometimes this fails due to adb

// ChromeDriver can return a positive status despite failing

// chromedriver will ask ADB to forward a port like "deviceId tcp:port localabstract:webview_devtools_remote_port"

// sometimes chromedriver stops automating webviews. this method runs a
// simple command to determine our state, and responds accordingly
//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUMsYUFBYSxHQUFHLGNBQWMsQ0FBQztBQUM1QyxZQUFZLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztBQUN2QyxZQUFZLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUN6QyxZQUFZLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztBQUNyQyxZQUFZLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUN6QyxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsWUFBWSxDQUFDOztxQkFFOUIsWUFBWSIsImZpbGUiOiJsaWIvY2hyb21lZHJpdmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNwaWxlOm1haW5cblxuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgSldQcm94eSB9IGZyb20gJ2FwcGl1bS1iYXNlLWRyaXZlcic7XG5pbXBvcnQgY3AgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCBsb2dnZXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoIH0gZnJvbSAnLi9pbnN0YWxsJztcblxuXG5jb25zdCBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKCdDaHJvbWVkcml2ZXInKTtcblxuY29uc3QgREVGQVVMVF9IT1NUID0gJzEyNy4wLjAuMSc7XG5jb25zdCBERUZBVUxUX1BPUlQgPSA5NTE1O1xuXG5jbGFzcyBDaHJvbWVkcml2ZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IHtob3N0LCBwb3J0LCBleGVjdXRhYmxlLCBjbWRBcmdzLCBhZGIsIHZlcmJvc2UsIGxvZ1BhdGh9ID0gYXJncztcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdCB8fCBERUZBVUxUX0hPU1Q7XG4gICAgdGhpcy5wcm94eVBvcnQgPSBwb3J0IHx8IERFRkFVTFRfUE9SVDtcbiAgICB0aGlzLmFkYiA9IGFkYjtcbiAgICB0aGlzLmNtZEFyZ3MgPSBjbWRBcmdzO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5jaHJvbWVkcml2ZXIgPSBleGVjdXRhYmxlO1xuICAgIHRoaXMuZXhlY3V0YWJsZVZlcmlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEO1xuICAgIHRoaXMuandwcm94eSA9IG5ldyBKV1Byb3h5KHtzZXJ2ZXI6IHRoaXMucHJveHlIb3N0LCBwb3J0OiB0aGlzLnByb3h5UG9ydH0pO1xuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gICAgdGhpcy5sb2dQYXRoID0gbG9nUGF0aDtcbiAgfVxuXG4gIGFzeW5jIGluaXRDaHJvbWVkcml2ZXJQYXRoICgpIHtcbiAgICBpZiAodGhpcy5leGVjdXRhYmxlVmVyaWZpZWQpIHJldHVybjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgbGV0IGJpblBhdGggPSB0aGlzLmNocm9tZWRyaXZlciB8fCAoYXdhaXQgZ2V0Q2hyb21lZHJpdmVyQmluYXJ5UGF0aCgpKTtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhiaW5QYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gdXNlIGEgY2hyb21lZHJpdmVyIGJpbmFyeSBhdCB0aGUgcGF0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJHtiaW5QYXRofSwgYnV0IGl0IGRvZXNuJ3QgZXhpc3QhYCk7XG4gICAgfVxuICAgIHRoaXMuY2hyb21lZHJpdmVyID0gYmluUGF0aDtcbiAgICB0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCA9IHRydWU7XG4gICAgbG9nLmluZm8oYFNldCBjaHJvbWVkcml2ZXIgYmluYXJ5IGFzOiAke3RoaXMuY2hyb21lZHJpdmVyfWApO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKGNhcHMsIGVtaXRTdGFydGluZ1N0YXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwcztcbiAgICBpZiAoZW1pdFN0YXJ0aW5nU3RhdGUpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcbiAgICB9XG5cbiAgICBsZXQgYXJncyA9IFtcIi0tdXJsLWJhc2U9d2QvaHViXCIsIGAtLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1gXTtcbiAgICBpZiAodGhpcy5hZGIgJiYgdGhpcy5hZGIuYWRiUG9ydCkge1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtgLS1hZGItcG9ydD0ke3RoaXMuYWRiLmFkYlBvcnR9YF0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbWRBcmdzKSB7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQodGhpcy5jbWRBcmdzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nUGF0aCkge1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtgLS1sb2ctcGF0aD0ke3RoaXMubG9nUGF0aH1gXSk7XG4gICAgfVxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbJy0tdmVyYm9zZSddKTtcbiAgICAvLyB3aGF0IGFyZSB0aGUgcHJvY2VzcyBzdGRvdXQvc3RkZXJyIGNvbmRpdGlvbnMgd2hlcmVpbiB3ZSBrbm93IHRoYXRcbiAgICAvLyB0aGUgcHJvY2VzcyBoYXMgc3RhcnRlZCB0byBvdXIgc2F0aXNmYWN0aW9uP1xuICAgIGNvbnN0IHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0KSA9PiB7XG4gICAgICByZXR1cm4gc3Rkb3V0LmluZGV4T2YoJ1N0YXJ0aW5nICcpID09PSAwO1xuICAgIH07XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0Q2hyb21lZHJpdmVyUGF0aCgpO1xuICAgICAgYXdhaXQgdGhpcy5raWxsQWxsKCk7XG5cbiAgICAgIC8vIHNldCB1cCBvdXIgc3VicHJvY2VzcyBvYmplY3RcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKHRoaXMuY2hyb21lZHJpdmVyLCBhcmdzKTtcbiAgICAgIHByb2Nlc3NJc0FsaXZlID0gdHJ1ZTtcblxuICAgICAgLy8gaGFuZGxlIGxvZyBvdXRwdXRcbiAgICAgIHRoaXMucHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgIC8vIGdpdmUgdGhlIG91dHB1dCBpZiBpdCBpcyByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgW1NURE9VVF0gJHtzdGRvdXQudHJpbSgpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoYFtTVERFUlJdICR7c3RkZXJyLnRyaW0oKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGNkIG91dHB1dCBpcyBub3QgcHJpbnRlZCwgZmluZCB0aGUgY2hyb21lIHZlcnNpb24gYW5kIHByaW50XG4gICAgICAgICAgLy8gd2lsbCBnZXQgYSByZXNwb25zZSBsaWtlXG4gICAgICAgICAgLy8gICBEZXZUb29scyByZXNwb25zZToge1xuICAgICAgICAgIC8vICAgICAgXCJBbmRyb2lkLVBhY2thZ2VcIjogXCJpby5hcHBpdW0uc2FtcGxlYXBwXCIsXG4gICAgICAgICAgLy8gICAgICBcIkJyb3dzZXJcIjogXCJDaHJvbWUvNTUuMC4yODgzLjkxXCIsXG4gICAgICAgICAgLy8gICAgICBcIlByb3RvY29sLVZlcnNpb25cIjogXCIxLjJcIixcbiAgICAgICAgICAvLyAgICAgIFwiVXNlci1BZ2VudFwiOiBcIi4uLlwiLFxuICAgICAgICAgIC8vICAgICAgXCJXZWJLaXQtVmVyc2lvblwiOiBcIjUzNy4zNlwiXG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgbGV0IG1hdGNoID0gL1wiQnJvd3NlclwiOiBcIiguKilcIi8uZXhlYyhzdGRvdXQgKyBzdGRlcnIpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBXZWJ2aWV3IHZlcnNpb246ICcke21hdGNoWzFdfSdgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgb3V0LW9mLWJvdW5kIGV4aXQgYnkgc2ltcGx5IGVtaXR0aW5nIGEgc3RvcHBlZCBzdGF0ZVxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcpIHtcbiAgICAgICAgICBsZXQgbXNnID0gYENocm9tZWRyaXZlciBleGl0ZWQgdW5leHBlY3RlZGx5IHdpdGggY29kZSAke2NvZGV9LCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHNpZ25hbCAke3NpZ25hbH1gO1xuICAgICAgICAgIGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKGBTcGF3bmluZyBjaHJvbWVkcml2ZXIgd2l0aDogJHt0aGlzLmNocm9tZWRyaXZlcn0gYCArXG4gICAgICAgICAgICAgICBgJHthcmdzLmpvaW4oJyAnKX1gKTtcbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuICAgICAgYXdhaXQgdGhpcy5zdGFydFNlc3Npb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcbiAgICAgIC8vIGp1c3QgYmVjYXVzZSB3ZSBoYWQgYW4gZXJyb3IgZG9lc24ndCBtZWFuIHRoZSBjaHJvbWVkcml2ZXIgcHJvY2Vzc1xuICAgICAgLy8gZmluaXNoZWQ7IHdlIHNob3VsZCBjbGVhbiB1cCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBvZnRlbiB0aGUgdXNlcidzIENocm9tZSB2ZXJzaW9uIGlzIHRvbyBsb3cgZm9yIHRoZSB2ZXJzaW9uIG9mIENocm9tZWRyaXZlclxuICAgICAgaWYgKGUubWVzc2FnZS5pbmRleE9mKCdDaHJvbWUgdmVyc2lvbiBtdXN0IGJlJykgIT09IC0xKSB7XG4gICAgICAgIGxvZy5lcnJvcignVW5hYmxlIHRvIGF1dG9tYXRlIENocm9tZSB2ZXJzaW9uIGJlY2F1c2UgaXQgaXMgdG9vIG9sZCBmb3IgdGhpcyB2ZXJzaW9uIG9mIENocm9tZWRyaXZlci4nKTtcbiAgICAgICAgbG9nLmVycm9yKGBQbGVhc2Ugc2VlICdodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9ibG9iL21hc3Rlci9kb2NzL2VuL2FkdmFuY2VkLWNvbmNlcHRzL2Nocm9tZWRyaXZlci5tZCdgKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgcmVzdGFydCAoKSB7XG4gICAgbG9nLmluZm8oXCJSZXN0YXJ0aW5nIGNocm9tZWRyaXZlclwiKTtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcmVzdGFydCB3aGVuIHdlJ3JlIG5vdCBvbmxpbmVcIik7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcpO1xuICAgIGF3YWl0IHRoaXMuc3RvcChmYWxzZSk7XG4gICAgYXdhaXQgdGhpcy5zdGFydCh0aGlzLmNhcGFiaWxpdGllcywgZmFsc2UpO1xuICB9XG5cbiAgX3N0YXRlUHJvbWlzZSAoc3RhdGUgPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBCKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChtc2cpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBudWxsIHx8IG1zZy5zdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICByZXNvbHZlKG1zZy5zdGF0ZSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihDaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbihDaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvck9ubGluZSAoKSB7XG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBDRCBoYXNuJ3QgY3Jhc2hlZFxuICAgIGxldCBjaHJvbWVkcml2ZXJTdG9wcGVkID0gZmFsc2U7XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgyMCwgMjAwLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQpIHtcbiAgICAgICAgLy8gd2UgYXJlIGVpdGhlciBzdG9wcGVkIG9yIHN0b3BwaW5nLCBzbyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICBjaHJvbWVkcml2ZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5nZXRTdGF0dXMoKTtcbiAgICB9KTtcbiAgICBpZiAoY2hyb21lZHJpdmVyU3RvcHBlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHJvbWVEcml2ZXIgY3Jhc2hlZCBkdXJpbmcgc3RhcnR1cC4nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTdGF0dXMgKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3N0YXR1cycsICdHRVQnKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0U2Vzc2lvbiAoKSB7XG4gICAgLy8gcmV0cnkgc2Vzc2lvbiBzdGFydCA0IHRpbWVzLCBzb21ldGltZXMgdGhpcyBmYWlscyBkdWUgdG8gYWRiXG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCg0LCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiB0aGlzLmNhcGFiaWxpdGllc30pO1xuICAgICAgLy8gQ2hyb21lRHJpdmVyIGNhbiByZXR1cm4gYSBwb3NpdGl2ZSBzdGF0dXMgZGVzcGl0ZSBmYWlsaW5nXG4gICAgICBpZiAocmVzLnN0YXR1cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLnZhbHVlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSk7XG4gIH1cblxuICBhc3luYyBzdG9wIChlbWl0U3RhdGVzID0gdHJ1ZSkge1xuICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnJywgJ0RFTEVURScpO1xuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAyMDAwMCk7XG4gICAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGxvZy5kZWJ1ZyhgQ2hhbmdlZCBzdGF0ZSB0byAnJHtzdGF0ZX0nYCk7XG4gICAgdGhpcy5lbWl0KENocm9tZWRyaXZlci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gIH1cblxuICBhc3luYyBwcm94eVJlcSAocmVxLCByZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LnByb3h5UmVxUmVzKHJlcSwgcmVzKTtcbiAgfVxuXG4gIGFzeW5jIGtpbGxBbGwgKCkge1xuICAgIGxldCBjbWQ7XG4gICAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgICAgLy8ganMgaGludCBjYW5ub3QgaGFuZGxlIGJhY2t0aWNrcywgZXZlbiBlc2NhcGVkLCB3aXRoaW4gdGVtcGxhdGUgbGl0ZXJhbHNcbiAgICAgIGNtZCA9IFwiRk9SIC9GIFxcXCJ1c2ViYWNrcSB0b2tlbnM9NVxcXCIgJWEgaW4gKGBuZXRzdGF0IC1uYW8gXnwgXCIgK1xuICAgICAgICAgICAgXCJmaW5kc3RyIC9SIC9DOlxcXCJcIiArIHRoaXMucHJveHlQb3J0ICsgXCIgXFxcImApIGRvIChcIiArXG4gICAgICAgICAgICBcIkZPUiAvRiBcXFwidXNlYmFja3FcXFwiICViIGluIChgVEFTS0xJU1QgL0ZJIFxcXCJQSUQgZXEgJWFcXFwiIF58IFwiICtcbiAgICAgICAgICAgIFwiZmluZHN0ciAvSSBjaHJvbWVkcml2ZXIuZXhlYCkgZG8gKElGIE5PVCAlYj09XFxcIlxcXCIgVEFTS0tJTEwgXCIgK1xuICAgICAgICAgICAgXCIvRiAvUElEICVhKSlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY21kID0gYHBraWxsIC0xNSAtZiBcIiR7dGhpcy5jaHJvbWVkcml2ZXJ9LiotLXBvcnQ9JHt0aGlzLnByb3h5UG9ydH1cImA7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhbnkgb2xkIGNocm9tZWRyaXZlcnMsIHJ1bm5pbmc6ICR7Y21kfWApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCAoQi5wcm9taXNpZnkoY3AuZXhlYykpKGNtZCk7XG4gICAgICBsb2cuZGVidWcoXCJTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgY2hyb21lZHJpdmVyc1wiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKFwiTm8gb2xkIGNocm9tZWRyaXZlcnMgc2VlbWVkIHRvIGV4aXN0XCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYikge1xuICAgICAgbG9nLmRlYnVnKGBDbGVhbmluZyBhbnkgb2xkIGFkYiBmb3J3YXJkZWQgcG9ydCBzb2NrZXQgY29ubmVjdGlvbnNgKTtcbiAgICAgIGZvciAobGV0IGNvbm4gb2YgYXdhaXQgdGhpcy5hZGIuZ2V0Rm9yd2FyZExpc3QoKSkge1xuICAgICAgICAvLyBjaHJvbWVkcml2ZXIgd2lsbCBhc2sgQURCIHRvIGZvcndhcmQgYSBwb3J0IGxpa2UgXCJkZXZpY2VJZCB0Y3A6cG9ydCBsb2NhbGFic3RyYWN0OndlYnZpZXdfZGV2dG9vbHNfcmVtb3RlX3BvcnRcIlxuICAgICAgICBpZiAoY29ubi5pbmRleE9mKCd3ZWJ2aWV3X2RldnRvb2xzJykgIT09IC0xKSB7XG4gICAgICAgICAgbGV0IHBhcmFtcyA9IGNvbm4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRiLnJlbW92ZVBvcnRGb3J3YXJkKHBhcmFtc1sxXS5yZXBsYWNlKC9bXFxEXSovLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhc1dvcmtpbmdXZWJ2aWV3ICgpIHtcbiAgICAvLyBzb21ldGltZXMgY2hyb21lZHJpdmVyIHN0b3BzIGF1dG9tYXRpbmcgd2Vidmlld3MuIHRoaXMgbWV0aG9kIHJ1bnMgYVxuICAgIC8vIHNpbXBsZSBjb21tYW5kIHRvIGRldGVybWluZSBvdXIgc3RhdGUsIGFuZCByZXNwb25kcyBhY2NvcmRpbmdseVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3VybCcsICdHRVQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SID0gJ2Nocm9tZWRyaXZlcl9lcnJvcic7XG5DaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcbkNocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HID0gJ3Jlc3RhcnRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBDaHJvbWVkcml2ZXI7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
