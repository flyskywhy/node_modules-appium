'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _desiredCaps = require('./desired-caps');

var _appiumSupport = require('appium-support');

// Takes primary caps object and merges it into a secondary caps object.
// (see https://www.w3.org/TR/webdriver/#dfn-merging-capabilities)
function mergeCaps() {
  var primary = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var secondary = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var result = _Object$assign({}, primary);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(secondary)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var _name = _step$value[0];
      var value = _step$value[1];

      // Overwriting is not allowed. Primary and secondary must have different properties (w3c rule 4.4)
      if (!_lodash2['default'].isUndefined(primary[_name])) {
        throw new Error('property ' + _name + ' should not exist on both primary and secondary');
      }
      result[_name] = value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

// Validates caps against a set of constraints
function validateCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var skipPresenceConstraint = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  if (!_lodash2['default'].isObject(caps)) {
    throw new Error('must be a JSON object');
  }

  constraints = _lodash2['default'].cloneDeep(constraints); // Defensive copy

  // Remove the 'presence' constraint if we're not checking for it
  if (skipPresenceConstraint) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(_Object$keys(constraints)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var key = _step2.value;

        delete constraints[key].presence;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var validationErrors = _desiredCaps.validator.validate(_lodash2['default'].pickBy(caps, _appiumSupport.util.hasValue), constraints, { fullMessages: false });

  if (validationErrors) {
    var message = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].toPairs(validationErrors)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var attribute = _step3$value[0];
        var reasons = _step3$value[1];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _getIterator(reasons), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var reason = _step4.value;

            message.push(' ' + attribute + ' ' + reason + ',');
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    throw new Error(message.join(''));
  }

  // Return caps
  return caps;
}

// Parse capabilities (based on https://www.w3.org/TR/webdriver/#processing-capabilities)
function parseCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  if (!_lodash2['default'].isObject(caps)) {
    throw new Error('The capabilities argument was not valid for the following reason(s): "capabilities" must be a JSON object.');
  }

  var requiredCaps = caps.alwaysMatch;
  var _caps$firstMatch = caps.firstMatch;
  var allFirstMatchCaps = _caps$firstMatch === undefined ? [] : _caps$firstMatch;

  if (!_lodash2['default'].isObject(requiredCaps)) {
    requiredCaps = {};
  }

  requiredCaps = validateCaps(requiredCaps, constraints);

  // Reject 'firstMatch' argument if it's not an array (see spec #3.2)
  if (!_lodash2['default'].isArray(allFirstMatchCaps)) {
    throw new Error('The capabilities.firstMatch argument was not valid for the following reason(s): "capabilities.firstMatch" must be a JSON array or undefined');
  }

  // Validate all of the first match capabilities (see spec #5)
  var validatedFirstMatchCaps = allFirstMatchCaps.map(function (firstMatchCaps) {
    try {
      return shouldValidateCaps ? validateCaps(firstMatchCaps, constraints) : firstMatchCaps;
    } catch (e) {
      throw new Error('The capabilities.firstMatch argument was not valid for the following reason: ' + firstMatchCaps + ' ' + e.message);
    }
  });

  // Try to merge requiredCaps with first match capabilities, break once it finds its first match (see spec #6)
  var matchedCaps = null;
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = _getIterator(validatedFirstMatchCaps), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var firstMatchCaps = _step5.value;

      try {
        matchedCaps = mergeCaps(requiredCaps, firstMatchCaps);
        if (matchedCaps) {
          break;
        }
      } catch (ign) {}
    }

    // If there was no match, use the de-facto requiredCaps on its own
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5['return']) {
        _iterator5['return']();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  matchedCaps = matchedCaps || requiredCaps;

  // Returns variables for testing purposes
  return { requiredCaps: requiredCaps, allFirstMatchCaps: allFirstMatchCaps, validatedFirstMatchCaps: validatedFirstMatchCaps, matchedCaps: matchedCaps };
}

// Calls parseCaps and just returns the matchedCaps variable
function processCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  return parseCaps(caps, constraints, shouldValidateCaps).matchedCaps;
}

exports['default'] = { parseCaps: parseCaps, processCaps: processCaps, validateCaps: validateCaps, mergeCaps: mergeCaps };
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFjLFFBQVE7Ozs7MkJBQ0ksZ0JBQWdCOzs2QkFDckIsZ0JBQWdCOzs7O0FBSXJDLFNBQVMsU0FBUyxHQUFnQztNQUE5QixPQUFPLHlEQUFHLEVBQUU7TUFBRSxTQUFTLHlEQUFHLEVBQUU7O0FBQzlDLE1BQUksTUFBTSxHQUFHLGVBQWMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7O0FBRXhDLHNDQUEwQixvQkFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLDRHQUFFOzs7VUFBdEMsS0FBSTtVQUFFLEtBQUs7OztBQUVuQixVQUFJLENBQUMsb0JBQUUsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFJLENBQUMsQ0FBQyxFQUFFO0FBQ2pDLGNBQU0sSUFBSSxLQUFLLGVBQWEsS0FBSSxxREFBa0QsQ0FBQztPQUNwRjtBQUNELFlBQU0sQ0FBQyxLQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7S0FDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxTQUFPLE1BQU0sQ0FBQztDQUNmOzs7QUFHRCxTQUFTLFlBQVksQ0FBRSxJQUFJLEVBQW9EO01BQWxELFdBQVcseURBQUcsRUFBRTtNQUFFLHNCQUFzQix5REFBRyxLQUFLOztBQUMzRSxNQUFJLENBQUMsb0JBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3JCLFVBQU0sSUFBSSxLQUFLLHlCQUF5QixDQUFDO0dBQzFDOztBQUVELGFBQVcsR0FBRyxvQkFBRSxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7OztBQUd2QyxNQUFJLHNCQUFzQixFQUFFOzs7Ozs7QUFDMUIseUNBQWdCLGFBQVksV0FBVyxDQUFDLGlIQUFFO1lBQWpDLEdBQUc7O0FBQ1YsZUFBTyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO09BQ2xDOzs7Ozs7Ozs7Ozs7Ozs7R0FDRjs7QUFFRCxNQUFJ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QUFFLFlBQVksRUFBWixZQUFZLEVBQUUsU0FBUyxFQUFULFNBQVMsRUFBRSIsImZpbGUiOiJsaWIvYmFzZWRyaXZlci9jYXBhYmlsaXRpZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgdmFsaWRhdG9yIH0gZnJvbSAnLi9kZXNpcmVkLWNhcHMnO1xuaW1wb3J0IHsgdXRpbCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcblxuLy8gVGFrZXMgcHJpbWFyeSBjYXBzIG9iamVjdCBhbmQgbWVyZ2VzIGl0IGludG8gYSBzZWNvbmRhcnkgY2FwcyBvYmplY3QuXG4vLyAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkcml2ZXIvI2Rmbi1tZXJnaW5nLWNhcGFiaWxpdGllcylcbmZ1bmN0aW9uIG1lcmdlQ2FwcyAocHJpbWFyeSA9IHt9LCBzZWNvbmRhcnkgPSB7fSkge1xuICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJpbWFyeSk7XG5cbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBfLnRvUGFpcnMoc2Vjb25kYXJ5KSkge1xuICAgIC8vIE92ZXJ3cml0aW5nIGlzIG5vdCBhbGxvd2VkLiBQcmltYXJ5IGFuZCBzZWNvbmRhcnkgbXVzdCBoYXZlIGRpZmZlcmVudCBwcm9wZXJ0aWVzICh3M2MgcnVsZSA0LjQpXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByaW1hcnlbbmFtZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3BlcnR5ICR7bmFtZX0gc2hvdWxkIG5vdCBleGlzdCBvbiBib3RoIHByaW1hcnkgYW5kIHNlY29uZGFyeWApO1xuICAgIH1cbiAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFZhbGlkYXRlcyBjYXBzIGFnYWluc3QgYSBzZXQgb2YgY29uc3RyYWludHNcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FwcyAoY2FwcywgY29uc3RyYWludHMgPSB7fSwgc2tpcFByZXNlbmNlQ29uc3RyYWludCA9IGZhbHNlKSB7XG4gIGlmICghXy5pc09iamVjdChjYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVzdCBiZSBhIEpTT04gb2JqZWN0YCk7XG4gIH1cblxuICBjb25zdHJhaW50cyA9IF8uY2xvbmVEZWVwKGNvbnN0cmFpbnRzKTsgLy8gRGVmZW5zaXZlIGNvcHlcblxuICAvLyBSZW1vdmUgdGhlICdwcmVzZW5jZScgY29uc3RyYWludCBpZiB3ZSdyZSBub3QgY2hlY2tpbmcgZm9yIGl0XG4gIGlmIChza2lwUHJlc2VuY2VDb25zdHJhaW50KSB7XG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbnN0cmFpbnRzKSkge1xuICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzW2tleV0ucHJlc2VuY2U7XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0b3IudmFsaWRhdGUoXy5waWNrQnkoY2FwcywgdXRpbC5oYXNWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bGxNZXNzYWdlczogZmFsc2V9KTtcblxuICBpZiAodmFsaWRhdGlvbkVycm9ycykge1xuICAgIGxldCBtZXNzYWdlID0gW107XG4gICAgZm9yIChsZXQgW2F0dHJpYnV0ZSwgcmVhc29uc10gb2YgXy50b1BhaXJzKHZhbGlkYXRpb25FcnJvcnMpKSB7XG4gICAgICBmb3IgKGxldCByZWFzb24gb2YgcmVhc29ucykge1xuICAgICAgICBtZXNzYWdlLnB1c2goYCAke2F0dHJpYnV0ZX0gJHtyZWFzb259LGApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5qb2luKCcnKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gY2Fwc1xuICByZXR1cm4gY2Fwcztcbn1cblxuLy8gUGFyc2UgY2FwYWJpbGl0aWVzIChiYXNlZCBvbiBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNwcm9jZXNzaW5nLWNhcGFiaWxpdGllcylcbmZ1bmN0aW9uIHBhcnNlQ2FwcyAoY2FwcywgY29uc3RyYWludHMgPSB7fSwgc2hvdWxkVmFsaWRhdGVDYXBzID0gdHJ1ZSkge1xuICBpZiAoIV8uaXNPYmplY3QoY2FwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYXBhYmlsaXRpZXMgYXJndW1lbnQgd2FzIG5vdCB2YWxpZCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb24ocyk6IFwiY2FwYWJpbGl0aWVzXCIgbXVzdCBiZSBhIEpTT04gb2JqZWN0LicpO1xuICB9XG5cbiAgbGV0IHthbHdheXNNYXRjaDogcmVxdWlyZWRDYXBzLCBmaXJzdE1hdGNoOiBhbGxGaXJzdE1hdGNoQ2FwcyA9IFtdfSA9IGNhcHM7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHJlcXVpcmVkQ2FwcykpIHtcbiAgICByZXF1aXJlZENhcHMgPSB7fTtcbiAgfVxuXG4gIHJlcXVpcmVkQ2FwcyA9IHZhbGlkYXRlQ2FwcyhyZXF1aXJlZENhcHMsIGNvbnN0cmFpbnRzKTtcblxuICAvLyBSZWplY3QgJ2ZpcnN0TWF0Y2gnIGFyZ3VtZW50IGlmIGl0J3Mgbm90IGFuIGFycmF5IChzZWUgc3BlYyAjMy4yKVxuICBpZiAoIV8uaXNBcnJheShhbGxGaXJzdE1hdGNoQ2FwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYXBhYmlsaXRpZXMuZmlyc3RNYXRjaCBhcmd1bWVudCB3YXMgbm90IHZhbGlkIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbihzKTogXCJjYXBhYmlsaXRpZXMuZmlyc3RNYXRjaFwiIG11c3QgYmUgYSBKU09OIGFycmF5IG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgYWxsIG9mIHRoZSBmaXJzdCBtYXRjaCBjYXBhYmlsaXRpZXMgKHNlZSBzcGVjICM1KVxuICBsZXQgdmFsaWRhdGVkRmlyc3RNYXRjaENhcHMgPSBhbGxGaXJzdE1hdGNoQ2Fwcy5tYXAoKGZpcnN0TWF0Y2hDYXBzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzaG91bGRWYWxpZGF0ZUNhcHMgPyB2YWxpZGF0ZUNhcHMoZmlyc3RNYXRjaENhcHMsIGNvbnN0cmFpbnRzKSA6IGZpcnN0TWF0Y2hDYXBzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhcGFiaWxpdGllcy5maXJzdE1hdGNoIGFyZ3VtZW50IHdhcyBub3QgdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uOiAke2ZpcnN0TWF0Y2hDYXBzfSAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRyeSB0byBtZXJnZSByZXF1aXJlZENhcHMgd2l0aCBmaXJzdCBtYXRjaCBjYXBhYmlsaXRpZXMsIGJyZWFrIG9uY2UgaXQgZmluZHMgaXRzIGZpcnN0IG1hdGNoIChzZWUgc3BlYyAjNilcbiAgbGV0IG1hdGNoZWRDYXBzID0gbnVsbDtcbiAgZm9yIChsZXQgZmlyc3RNYXRjaENhcHMgb2YgdmFsaWRhdGVkRmlyc3RNYXRjaENhcHMpIHtcbiAgICB0cnkge1xuICAgICAgbWF0Y2hlZENhcHMgPSBtZXJnZUNhcHMocmVxdWlyZWRDYXBzLCBmaXJzdE1hdGNoQ2Fwcyk7XG4gICAgICBpZiAobWF0Y2hlZENhcHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoaWduKSB7IH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdhcyBubyBtYXRjaCwgdXNlIHRoZSBkZS1mYWN0byByZXF1aXJlZENhcHMgb24gaXRzIG93blxuICBtYXRjaGVkQ2FwcyA9IG1hdGNoZWRDYXBzIHx8IHJlcXVpcmVkQ2FwcztcblxuICAvLyBSZXR1cm5zIHZhcmlhYmxlcyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICByZXR1cm4ge3JlcXVpcmVkQ2FwcywgYWxsRmlyc3RNYXRjaENhcHMsIHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzLCBtYXRjaGVkQ2Fwc307XG59XG5cbi8vIENhbGxzIHBhcnNlQ2FwcyBhbmQganVzdCByZXR1cm5zIHRoZSBtYXRjaGVkQ2FwcyB2YXJpYWJsZVxuZnVuY3Rpb24gcHJvY2Vzc0NhcHMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNob3VsZFZhbGlkYXRlQ2FwcyA9IHRydWUpIHtcbiAgcmV0dXJuIHBhcnNlQ2FwcyhjYXBzLCBjb25zdHJhaW50cywgc2hvdWxkVmFsaWRhdGVDYXBzKS5tYXRjaGVkQ2Fwcztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlQ2FwcywgcHJvY2Vzc0NhcHMsIHZhbGlkYXRlQ2FwcywgbWVyZ2VDYXBzIH07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
