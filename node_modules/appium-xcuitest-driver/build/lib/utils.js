'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _appiumIosDriver = require('appium-ios-driver');

var _teen_process = require('teen_process');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _asyncLock = require('async-lock');

var _asyncLock2 = _interopRequireDefault(_asyncLock);

var DEFAULT_TIMEOUT_KEY = 'default';

function detectUdid() {
  var cmd, args, udid, _ref, stdout, udids;

  return _regeneratorRuntime.async(function detectUdid$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Auto-detecting real device udid...');
        cmd = undefined, args = [];
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevice_id'));

      case 5:
        cmd = context$1$0.sent;

        args.push('-l');
        _logger2['default'].debug('Using idevice_id');
        context$1$0.next = 14;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](2);

        _logger2['default'].debug('Using udidetect');
        cmd = require.resolve('udidetect');

      case 14:
        udid = undefined;
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: 3000 }));

      case 18:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        udids = _lodash2['default'].filter(stdout.split('\n'), Boolean);

        udid = _lodash2['default'].last(udids);
        if (udids.length > 1) {
          _logger2['default'].warn('Multiple devices found: ' + udids.join(', '));
          _logger2['default'].warn('Choosing \'' + udid + '\'. If this is wrong, manually set with \'udid\' desired capability');
        }
        context$1$0.next = 28;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t1 = context$1$0['catch'](15);

        _logger2['default'].errorAndThrow('Error detecting udid: ' + context$1$0.t1.message);

      case 28:
        if (!(!udid || udid.length <= 2)) {
          context$1$0.next = 30;
          break;
        }

        throw new Error('Could not detect udid.');

      case 30:
        _logger2['default'].debug('Detected real device udid: \'' + udid + '\'');
        return context$1$0.abrupt('return', udid);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 10], [15, 25]]);
}

function getAndCheckXcodeVersion() {
  var version;
  return _regeneratorRuntime.async(function getAndCheckXcodeVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        version = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

      case 4:
        version = context$1$0.sent;
        context$1$0.next = 11;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug(context$1$0.t0);
        _logger2['default'].errorAndThrow('Could not determine Xcode version: ' + context$1$0.t0.message);

      case 11:
        if (version.toolsVersion) {
          context$1$0.next = 20;
          break;
        }

        context$1$0.prev = 12;
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getCommandLineToolsVersion());

      case 15:
        version.toolsVersion = context$1$0.sent;
        context$1$0.next = 20;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t1 = context$1$0['catch'](12);

      case 20:

        // we do not support Xcodes < 7.3,
        if (version.versionFloat < 7.3) {
          _logger2['default'].errorAndThrow('Xcode version \'' + version.versionString + '\'. Support for ' + ('Xcode ' + version.versionString + ' is not supported. ') + 'Please upgrade to version 7.3 or higher');
        }
        return context$1$0.abrupt('return', version);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7], [12, 18]]);
}

function getAndCheckIosSdkVersion() {
  var versionNumber;
  return _regeneratorRuntime.async(function getAndCheckIosSdkVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        versionNumber = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getMaxIOSSDK());

      case 4:
        versionNumber = context$1$0.sent;
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].errorAndThrow('Could not determine iOS SDK version: ' + context$1$0.t0.message);

      case 10:
        return context$1$0.abrupt('return', versionNumber);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
}

function translateDeviceName(pv) {
  var dn = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
  var deviceName;
  return _regeneratorRuntime.async(function translateDeviceName$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        deviceName = dn;

        if (dn.toLowerCase() === 'iphone simulator') {
          deviceName = 'iPhone 6';
        } else if (dn.toLowerCase() === 'ipad simulator') {
          if (parseFloat(pv).toFixed(1) < "10.3") {
            deviceName = 'iPad Retina';
          } else {
            /* iPad Retina is no longer available for ios 10.3
            so we pick another iPad to use as default */
            deviceName = 'iPad Air';
          }
        }
        if (deviceName !== dn) {
          _logger2['default'].debug('Changing deviceName from \'' + dn + '\' to \'' + deviceName + '\'');
        }
        return context$1$0.abrupt('return', deviceName);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data attachment folders as keys
// and values are stacks of permssion masks
// It is used to synchronize permissions change
// on shared folders
var derivedDataPermissionsStacks = new _Map();
var permissionsSettingLock = new _asyncLock2['default']();

function adjustWDAAttachmentsPermissions(wda, perms) {
  var attachmentsFolder, shouldChangePerms;
  return _regeneratorRuntime.async(function adjustWDAAttachmentsPermissions$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to set permissions on WDA attachments folder');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        attachmentsFolder = context$1$0.t1.join.call(context$1$0.t1, context$1$0.t2, 'Logs/Test/Attachments');
        shouldChangePerms = false;
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(permissionsSettingLock.acquire(adjustWDAAttachmentsPermissions.name, function callee$1$0() {
          var permsStack;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                permsStack = derivedDataPermissionsStacks.get(attachmentsFolder) || [];

                if (!permsStack.length) {
                  context$2$0.next = 10;
                  break;
                }

                if (!(_lodash2['default'].last(permsStack) === perms)) {
                  context$2$0.next = 6;
                  break;
                }

                permsStack.push(perms);
                _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because they were already set by the other session');
                return context$2$0.abrupt('return');

              case 6:
                if (!(permsStack.length > 1)) {
                  context$2$0.next = 10;
                  break;
                }

                permsStack.pop();
                _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because the other session does not expect them to be changed');
                return context$2$0.abrupt('return');

              case 10:
                derivedDataPermissionsStacks.set(attachmentsFolder, [perms]);
                shouldChangePerms = true;

              case 12:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 16:
        if (shouldChangePerms) {
          context$1$0.next = 18;
          break;
        }

        return context$1$0.abrupt('return');

      case 18:
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(attachmentsFolder));

      case 20:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        _logger2['default'].info('Setting \'' + perms + '\' permissions to \'' + attachmentsFolder + '\' folder');
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.chmod(attachmentsFolder, perms));

      case 24:
        return context$1$0.abrupt('return');

      case 25:
        _logger2['default'].info('There is no ' + attachmentsFolder + ' folder, so not changing permissions');

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data logs folders as keys
// and values are the count of times the particular
// folder has been scheduled for removal
var derivedDataCleanupMarkers = new _Map();
var cleanupLock = new _asyncLock2['default']();

function markSystemFilesForCleanup(wda) {
  var logsRoot;
  return _regeneratorRuntime.async(function markSystemFilesForCleanup$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to mark system files for cleanup');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(cleanupLock.acquire(clearSystemFiles.name, function callee$1$0() {
          var markersCount;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                markersCount = 0;

                if (derivedDataCleanupMarkers.has(logsRoot)) {
                  markersCount = derivedDataCleanupMarkers.get(logsRoot);
                }
                derivedDataCleanupMarkers.set(logsRoot, ++markersCount);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function clearSystemFiles(wda) {
  var logsRoot, shouldPerformCleanup;
  return _regeneratorRuntime.async(function clearSystemFiles$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to clear system files');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');
        shouldPerformCleanup = false;
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(cleanupLock.acquire(clearSystemFiles.name, function callee$1$0() {
          var markersCount;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!derivedDataCleanupMarkers.has(logsRoot)) {
                  context$2$0.next = 6;
                  break;
                }

                markersCount = derivedDataCleanupMarkers.get(logsRoot);

                derivedDataCleanupMarkers.set(logsRoot, --markersCount);

                if (!(markersCount > 0)) {
                  context$2$0.next = 6;
                  break;
                }

                _logger2['default'].info('Not cleaning \'' + logsRoot + '\' folder, because the other session does not expect it to be cleaned');
                return context$2$0.abrupt('return');

              case 6:
                derivedDataCleanupMarkers.set(logsRoot, 0);
                shouldPerformCleanup = true;

              case 8:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }));

      case 16:
        if (shouldPerformCleanup) {
          context$1$0.next = 18;
          break;
        }

        return context$1$0.abrupt('return');

      case 18:
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(logsRoot));

      case 20:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        _logger2['default'].info('Cleaning test logs in \'' + logsRoot + '\' folder');
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(_appiumIosDriver.utils.clearLogs([logsRoot]));

      case 24:
        return context$1$0.abrupt('return');

      case 25:
        _logger2['default'].info('There is no ' + logsRoot + ' folder, so not cleaning files');

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function checkAppPresent(app) {
  return _regeneratorRuntime.async(function checkAppPresent$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Checking whether app \'' + app + '\' is actually present on file system');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(app));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        _logger2['default'].errorAndThrow('Could not find app at \'' + app + '\'');

      case 5:
        _logger2['default'].debug('App is present');

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getDriverInfo() {
  var stat, built, pkg, version, info;
  return _regeneratorRuntime.async(function getDriverInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(_path2['default'].resolve(__dirname, '..')));

      case 2:
        stat = context$1$0.sent;
        built = stat.mtime.getTime();
        pkg = require(__filename.indexOf('build/lib/utils') !== -1 ? '../../package.json' : '../package.json');
        version = pkg.version;
        info = {
          built: built,
          version: version
        };
        return context$1$0.abrupt('return', info);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function normalizeCommandTimeouts(value) {
  // The value is normalized already
  if (typeof value !== 'string') {
    return value;
  }

  var result = {};
  // Use as default timeout for all commands if a single integer value is provided
  if (!isNaN(value)) {
    result[DEFAULT_TIMEOUT_KEY] = _lodash2['default'].toInteger(value);
    return result;
  }

  // JSON object has been provided. Let's parse it
  try {
    result = JSON.parse(value);
    if (!_lodash2['default'].isPlainObject(result)) {
      throw new Error();
    }
  } catch (err) {
    _logger2['default'].errorAndThrow('"commandTimeouts" capability should be a valid JSON object. "' + value + '" was given instead');
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(result)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var cmd = _step$value[0];
      var timeout = _step$value[1];

      if (!_lodash2['default'].isInteger(timeout) || timeout <= 0) {
        _logger2['default'].errorAndThrow('The timeout for "' + cmd + '" should be a valid natural number of milliseconds. "' + timeout + '" was given instead');
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

/**
 * Get the process id of the most recent running application
 * having the particular command line pattern.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 * @return {string} Either a process id or null if no matches were found.
 */
function getPidUsingPattern(pgrepPattern) {
  var args, _ref2, stdout, pid;

  return _regeneratorRuntime.async(function getPidUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-nif', pgrepPattern];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', args));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        pid = parseInt(stdout, 10);

        if (!isNaN(pid)) {
          context$1$0.next = 10;
          break;
        }

        _logger2['default'].debug('Cannot parse process id from \'pgrep ' + args.join(' ') + '\' output: ' + stdout);
        return context$1$0.abrupt('return', null);

      case 10:
        return context$1$0.abrupt('return', '' + pid);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug('\'pgrep ' + args.join(' ') + '\' didn\'t detect any matching processes. Return code: ' + context$1$0.t0.code);
        return context$1$0.abrupt('return', null);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 13]]);
}

/**
 * Kill a process having the particular command line pattern.
 * This method tries to send SIGINT, SIGTERM and SIGKILL to the
 * matched processes in this order if the process is still running.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 */
function killAppUsingPattern(pgrepPattern) {
  var _arr, _i, signal, args;

  return _regeneratorRuntime.async(function killAppUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _arr = [2, 15, 9];
        _i = 0;

      case 2:
        if (!(_i < _arr.length)) {
          context$1$0.next = 22;
          break;
        }

        signal = _arr[_i];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(getPidUsingPattern(pgrepPattern));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        return context$1$0.abrupt('return');

      case 8:
        args = ['-' + signal, '-if', pgrepPattern];
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);

        _logger2['default'].debug('pkill ' + args.join(' ') + ' -> ' + context$1$0.t0.message);

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(100));

      case 19:
        _i++;
        context$1$0.next = 2;
        break;

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
}

/**
 * Kills running XCTest processes for the particular device.
 *
 * @param {string} udid - The device UDID.
 * @param {boolean} isSimulator - Equals to true if the current device is a Simulator
 * @param {object} opts - Additional options mapping. Possible keys are:
 *   - {string|number} wdaLocalPort: The number of local port WDA is listening on.
 */
function resetXCTestProcesses(udid, isSimulator) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var processPatterns, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, pgrepPattern;

  return _regeneratorRuntime.async(function resetXCTestProcesses$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        processPatterns = ['xcodebuild.*' + udid];

        if (opts.wdaLocalPort) {
          processPatterns.push('iproxy ' + opts.wdaLocalPort);
        } else if (!isSimulator) {
          processPatterns.push('iproxy.*' + udid);
        }
        if (isSimulator) {
          processPatterns.push(udid + '.*XCTRunner');
        }
        _logger2['default'].debug('Killing running processes \'' + processPatterns.join(', ') + '\' for the device ' + udid + '...');
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 7;
        _iterator2 = _getIterator(processPatterns);

      case 9:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 16;
          break;
        }

        pgrepPattern = _step2.value;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(killAppUsingPattern(pgrepPattern));

      case 13:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 9;
        break;

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

exports.detectUdid = detectUdid;
exports.getAndCheckXcodeVersion = getAndCheckXcodeVersion;
exports.getAndCheckIosSdkVersion = getAndCheckIosSdkVersion;
exports.adjustWDAAttachmentsPermissions = adjustWDAAttachmentsPermissions;
exports.checkAppPresent = checkAppPresent;
exports.getDriverInfo = getDriverInfo;
exports.clearSystemFiles = clearSystemFiles;
exports.translateDeviceName = translateDeviceName;
exports.normalizeCommandTimeouts = normalizeCommandTimeouts;
exports.DEFAULT_TIMEOUT_KEY = DEFAULT_TIMEOUT_KEY;
exports.resetXCTestProcesses = resetXCTestProcesses;
exports.getPidUsingPattern = getPidUsingPattern;
exports.markSystemFilesForCleanup = markSystemFilesForCleanup;

// only want to clear the system files for the particular WDA xcode run

// get the package.json and the version from it
//# sourceMappingURL=data:application/json;charset=utf8;base64,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V0FBVyxFQUFFO0FBQ2YseUJBQWUsQ0FBQyxJQUFJLENBQUksSUFBSSxpQkFBYyxDQUFDO1NBQzVDO0FBQ0QsNEJBQUksS0FBSyxrQ0FBK0IsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMEJBQW9CLElBQUksU0FBTSxDQUFDOzs7OztrQ0FDdEUsZUFBZTs7Ozs7Ozs7QUFBL0Isb0JBQVk7O3lDQUNmLG1CQUFtQixDQUFDLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQUUxQzs7UUFFUSxVQUFVLEdBQVYsVUFBVTtRQUFFLHVCQUF1QixHQUF2Qix1QkFBdUI7UUFBRSx3QkFBd0IsR0FBeEIsd0JBQXdCO1FBQzdELCtCQUErQixHQUEvQiwrQkFBK0I7UUFBRSxlQUFlLEdBQWYsZUFBZTtRQUFFLGFBQWEsR0FBYixhQUFhO1FBQy9ELGdCQUFnQixHQUFoQixnQkFBZ0I7UUFBRSxtQkFBbUIsR0FBbkIsbUJBQW1CO1FBQUUsd0JBQXdCLEdBQXhCLHdCQUF3QjtRQUMvRCxtQkFBbUIsR0FBbkIsbUJBQW1CO1FBQUUsb0JBQW9CLEdBQXBCLG9CQUFvQjtRQUFFLGtCQUFrQixHQUFsQixrQkFBa0I7UUFDN0QseUJBQXlCLEdBQXpCLHlCQUF5QiIsImZpbGUiOiJsaWIvdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgdXRpbHMgYXMgaW9zVXRpbHMgfSBmcm9tICdhcHBpdW0taW9zLWRyaXZlcic7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB4Y29kZSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcblxuXG5jb25zdCBERUZBVUxUX1RJTUVPVVRfS0VZID0gJ2RlZmF1bHQnO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdFVkaWQgKCkge1xuICBsb2cuZGVidWcoJ0F1dG8tZGV0ZWN0aW5nIHJlYWwgZGV2aWNlIHVkaWQuLi4nKTtcbiAgbGV0ICBjbWQsIGFyZ3MgPSBbXTtcbiAgdHJ5IHtcbiAgICBjbWQgPSBhd2FpdCBmcy53aGljaCgnaWRldmljZV9pZCcpO1xuICAgIGFyZ3MucHVzaCgnLWwnKTtcbiAgICBsb2cuZGVidWcoJ1VzaW5nIGlkZXZpY2VfaWQnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKCdVc2luZyB1ZGlkZXRlY3QnKTtcbiAgICBjbWQgPSByZXF1aXJlLnJlc29sdmUoJ3VkaWRldGVjdCcpO1xuICB9XG4gIGxldCB1ZGlkO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBhcmdzLCB7dGltZW91dDogMzAwMH0pO1xuICAgIGxldCB1ZGlkcyA9IF8uZmlsdGVyKHN0ZG91dC5zcGxpdCgnXFxuJyksIEJvb2xlYW4pO1xuICAgIHVkaWQgPSBfLmxhc3QodWRpZHMpO1xuICAgIGlmICh1ZGlkcy5sZW5ndGggPiAxKSB7XG4gICAgICBsb2cud2FybihgTXVsdGlwbGUgZGV2aWNlcyBmb3VuZDogJHt1ZGlkcy5qb2luKCcsICcpfWApO1xuICAgICAgbG9nLndhcm4oYENob29zaW5nICcke3VkaWR9Jy4gSWYgdGhpcyBpcyB3cm9uZywgbWFudWFsbHkgc2V0IHdpdGggJ3VkaWQnIGRlc2lyZWQgY2FwYWJpbGl0eWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGRldGVjdGluZyB1ZGlkOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG4gIGlmICghdWRpZCB8fCB1ZGlkLmxlbmd0aCA8PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZWN0IHVkaWQuJyk7XG4gIH1cbiAgbG9nLmRlYnVnKGBEZXRlY3RlZCByZWFsIGRldmljZSB1ZGlkOiAnJHt1ZGlkfSdgKTtcbiAgcmV0dXJuIHVkaWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFuZENoZWNrWGNvZGVWZXJzaW9uICgpIHtcbiAgbGV0IHZlcnNpb247XG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IGF3YWl0IHhjb2RlLmdldFZlcnNpb24odHJ1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5kZWJ1ZyhlcnIpO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZGV0ZXJtaW5lIFhjb2RlIHZlcnNpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cblxuICBpZiAoIXZlcnNpb24udG9vbHNWZXJzaW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZlcnNpb24udG9vbHNWZXJzaW9uID0gYXdhaXQgeGNvZGUuZ2V0Q29tbWFuZExpbmVUb29sc1ZlcnNpb24oKTtcbiAgICB9IGNhdGNoIChpZ24pIHt9XG4gIH1cblxuICAvLyB3ZSBkbyBub3Qgc3VwcG9ydCBYY29kZXMgPCA3LjMsXG4gIGlmICh2ZXJzaW9uLnZlcnNpb25GbG9hdCA8IDcuMykge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBYY29kZSB2ZXJzaW9uICcke3ZlcnNpb24udmVyc2lvblN0cmluZ30nLiBTdXBwb3J0IGZvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgWGNvZGUgJHt2ZXJzaW9uLnZlcnNpb25TdHJpbmd9IGlzIG5vdCBzdXBwb3J0ZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBQbGVhc2UgdXBncmFkZSB0byB2ZXJzaW9uIDcuMyBvciBoaWdoZXJgKTtcbiAgfVxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5kQ2hlY2tJb3NTZGtWZXJzaW9uICgpIHtcbiAgbGV0IHZlcnNpb25OdW1iZXI7XG4gIHRyeSB7XG4gICAgdmVyc2lvbk51bWJlciA9IGF3YWl0IHhjb2RlLmdldE1heElPU1NESygpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ291bGQgbm90IGRldGVybWluZSBpT1MgU0RLIHZlcnNpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHZlcnNpb25OdW1iZXI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zbGF0ZURldmljZU5hbWUgKHB2LCBkbiA9ICcnKSB7XG4gIGxldCBkZXZpY2VOYW1lID0gZG47XG4gIGlmIChkbi50b0xvd2VyQ2FzZSgpID09PSAnaXBob25lIHNpbXVsYXRvcicpIHtcbiAgICBkZXZpY2VOYW1lID0gJ2lQaG9uZSA2JztcbiAgfSBlbHNlIGlmIChkbi50b0xvd2VyQ2FzZSgpID09PSAnaXBhZCBzaW11bGF0b3InKSB7XG4gICAgaWYgKHBhcnNlRmxvYXQocHYpLnRvRml4ZWQoMSkgPCBcIjEwLjNcIikge1xuICAgICAgZGV2aWNlTmFtZSA9ICdpUGFkIFJldGluYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlQYWQgUmV0aW5hIGlzIG5vIGxvbmdlciBhdmFpbGFibGUgZm9yIGlvcyAxMC4zXG4gICAgICBzbyB3ZSBwaWNrIGFub3RoZXIgaVBhZCB0byB1c2UgYXMgZGVmYXVsdCAqL1xuICAgICAgZGV2aWNlTmFtZSA9ICdpUGFkIEFpcic7XG4gICAgfVxuICB9XG4gIGlmIChkZXZpY2VOYW1lICE9PSBkbikge1xuICAgIGxvZy5kZWJ1ZyhgQ2hhbmdpbmcgZGV2aWNlTmFtZSBmcm9tICcke2RufScgdG8gJyR7ZGV2aWNlTmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGRldmljZU5hbWU7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBhdHRhY2htZW50IGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgc3RhY2tzIG9mIHBlcm1zc2lvbiBtYXNrc1xuLy8gSXQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBwZXJtaXNzaW9ucyBjaGFuZ2Vcbi8vIG9uIHNoYXJlZCBmb2xkZXJzXG5jb25zdCBkZXJpdmVkRGF0YVBlcm1pc3Npb25zU3RhY2tzID0gbmV3IE1hcCgpO1xuY29uc3QgcGVybWlzc2lvbnNTZXR0aW5nTG9jayA9IG5ldyBBc3luY0xvY2soKTtcblxuYXN5bmMgZnVuY3Rpb24gYWRqdXN0V0RBQXR0YWNobWVudHNQZXJtaXNzaW9ucyAod2RhLCBwZXJtcykge1xuICBpZiAoIXdkYSB8fCAhYXdhaXQgd2RhLnJldHJpZXZlRGVyaXZlZERhdGFQYXRoKCkpIHtcbiAgICBsb2cud2FybignTm8gV2ViRHJpdmVyQWdlbnQgZGVyaXZlZCBkYXRhIGF2YWlsYWJsZSwgc28gdW5hYmxlIHRvIHNldCBwZXJtaXNzaW9ucyBvbiBXREEgYXR0YWNobWVudHMgZm9sZGVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYXR0YWNobWVudHNGb2xkZXIgPSBwYXRoLmpvaW4oYXdhaXQgd2RhLnJldHJpZXZlRGVyaXZlZERhdGFQYXRoKCksICdMb2dzL1Rlc3QvQXR0YWNobWVudHMnKTtcbiAgbGV0IHNob3VsZENoYW5nZVBlcm1zID0gZmFsc2U7XG4gIGF3YWl0IHBlcm1pc3Npb25zU2V0dGluZ0xvY2suYWNxdWlyZShhZGp1c3RXREFBdHRhY2htZW50c1Blcm1pc3Npb25zLm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBwZXJtc1N0YWNrID0gZGVyaXZlZERhdGFQZXJtaXNzaW9uc1N0YWNrcy5nZXQoYXR0YWNobWVudHNGb2xkZXIpIHx8IFtdO1xuICAgIGlmIChwZXJtc1N0YWNrLmxlbmd0aCkge1xuICAgICAgaWYgKF8ubGFzdChwZXJtc1N0YWNrKSA9PT0gcGVybXMpIHtcbiAgICAgICAgcGVybXNTdGFjay5wdXNoKHBlcm1zKTtcbiAgICAgICAgbG9nLmluZm8oYE5vdCBjaGFuZ2luZyBwZXJtaXNzaW9ucyBvZiAnJHthdHRhY2htZW50c0ZvbGRlcn0nIHRvICcke3Blcm1zfScsIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgc2V0IGJ5IHRoZSBvdGhlciBzZXNzaW9uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwZXJtc1N0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGVybXNTdGFjay5wb3AoKTtcbiAgICAgICAgbG9nLmluZm8oYE5vdCBjaGFuZ2luZyBwZXJtaXNzaW9ucyBvZiAnJHthdHRhY2htZW50c0ZvbGRlcn0nIHRvICcke3Blcm1zfScsIGJlY2F1c2UgdGhlIG90aGVyIHNlc3Npb24gZG9lcyBub3QgZXhwZWN0IHRoZW0gdG8gYmUgY2hhbmdlZGApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGRlcml2ZWREYXRhUGVybWlzc2lvbnNTdGFja3Muc2V0KGF0dGFjaG1lbnRzRm9sZGVyLCBbcGVybXNdKTtcbiAgICBzaG91bGRDaGFuZ2VQZXJtcyA9IHRydWU7XG4gIH0pO1xuICBpZiAoIXNob3VsZENoYW5nZVBlcm1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdHRhY2htZW50c0ZvbGRlcikpIHtcbiAgICBsb2cuaW5mbyhgU2V0dGluZyAnJHtwZXJtc30nIHBlcm1pc3Npb25zIHRvICcke2F0dGFjaG1lbnRzRm9sZGVyfScgZm9sZGVyYCk7XG4gICAgYXdhaXQgZnMuY2htb2QoYXR0YWNobWVudHNGb2xkZXIsIHBlcm1zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9nLmluZm8oYFRoZXJlIGlzIG5vICR7YXR0YWNobWVudHNGb2xkZXJ9IGZvbGRlciwgc28gbm90IGNoYW5naW5nIHBlcm1pc3Npb25zYCk7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBsb2dzIGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgdGhlIGNvdW50IG9mIHRpbWVzIHRoZSBwYXJ0aWN1bGFyXG4vLyBmb2xkZXIgaGFzIGJlZW4gc2NoZWR1bGVkIGZvciByZW1vdmFsXG5jb25zdCBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgY2xlYW51cExvY2sgPSBuZXcgQXN5bmNMb2NrKCk7XG5cbmFzeW5jIGZ1bmN0aW9uIG1hcmtTeXN0ZW1GaWxlc0ZvckNsZWFudXAgKHdkYSkge1xuICBpZiAoIXdkYSB8fCAhYXdhaXQgd2RhLnJldHJpZXZlRGVyaXZlZERhdGFQYXRoKCkpIHtcbiAgICBsb2cud2FybignTm8gV2ViRHJpdmVyQWdlbnQgZGVyaXZlZCBkYXRhIGF2YWlsYWJsZSwgc28gdW5hYmxlIHRvIG1hcmsgc3lzdGVtIGZpbGVzIGZvciBjbGVhbnVwJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbG9nc1Jvb3QgPSBwYXRoLnJlc29sdmUoYXdhaXQgd2RhLnJldHJpZXZlRGVyaXZlZERhdGFQYXRoKCksICdMb2dzJyk7XG4gIGF3YWl0IGNsZWFudXBMb2NrLmFjcXVpcmUoY2xlYXJTeXN0ZW1GaWxlcy5uYW1lLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IG1hcmtlcnNDb3VudCA9IDA7XG4gICAgaWYgKGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuaGFzKGxvZ3NSb290KSkge1xuICAgICAgbWFya2Vyc0NvdW50ID0gZGVyaXZlZERhdGFDbGVhbnVwTWFya2Vycy5nZXQobG9nc1Jvb3QpO1xuICAgIH1cbiAgICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgKyttYXJrZXJzQ291bnQpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2xlYXJTeXN0ZW1GaWxlcyAod2RhKSB7XG4gIC8vIG9ubHkgd2FudCB0byBjbGVhciB0aGUgc3lzdGVtIGZpbGVzIGZvciB0aGUgcGFydGljdWxhciBXREEgeGNvZGUgcnVuXG4gIGlmICghd2RhIHx8ICFhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSkge1xuICAgIGxvZy53YXJuKCdObyBXZWJEcml2ZXJBZ2VudCBkZXJpdmVkIGRhdGEgYXZhaWxhYmxlLCBzbyB1bmFibGUgdG8gY2xlYXIgc3lzdGVtIGZpbGVzJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbG9nc1Jvb3QgPSBwYXRoLnJlc29sdmUoYXdhaXQgd2RhLnJldHJpZXZlRGVyaXZlZERhdGFQYXRoKCksICdMb2dzJyk7XG4gIGxldCBzaG91bGRQZXJmb3JtQ2xlYW51cCA9IGZhbHNlO1xuICBhd2FpdCBjbGVhbnVwTG9jay5hY3F1aXJlKGNsZWFyU3lzdGVtRmlsZXMubmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLmhhcyhsb2dzUm9vdCkpIHtcbiAgICAgIGxldCBtYXJrZXJzQ291bnQgPSBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLmdldChsb2dzUm9vdCk7XG4gICAgICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgLS1tYXJrZXJzQ291bnQpO1xuICAgICAgaWYgKG1hcmtlcnNDb3VudCA+IDApIHtcbiAgICAgICAgbG9nLmluZm8oYE5vdCBjbGVhbmluZyAnJHtsb2dzUm9vdH0nIGZvbGRlciwgYmVjYXVzZSB0aGUgb3RoZXIgc2Vzc2lvbiBkb2VzIG5vdCBleHBlY3QgaXQgdG8gYmUgY2xlYW5lZGApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuc2V0KGxvZ3NSb290LCAwKTtcbiAgICBzaG91bGRQZXJmb3JtQ2xlYW51cCA9IHRydWU7XG4gIH0pO1xuICBpZiAoIXNob3VsZFBlcmZvcm1DbGVhbnVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2dzUm9vdCkpIHtcbiAgICBsb2cuaW5mbyhgQ2xlYW5pbmcgdGVzdCBsb2dzIGluICcke2xvZ3NSb290fScgZm9sZGVyYCk7XG4gICAgYXdhaXQgaW9zVXRpbHMuY2xlYXJMb2dzKFtsb2dzUm9vdF0pO1xuICAgIHJldHVybjtcbiAgfVxuICBsb2cuaW5mbyhgVGhlcmUgaXMgbm8gJHtsb2dzUm9vdH0gZm9sZGVyLCBzbyBub3QgY2xlYW5pbmcgZmlsZXNgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tBcHBQcmVzZW50IChhcHApIHtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyB3aGV0aGVyIGFwcCAnJHthcHB9JyBpcyBhY3R1YWxseSBwcmVzZW50IG9uIGZpbGUgc3lzdGVtYCk7XG4gIGlmICghKGF3YWl0IGZzLmV4aXN0cyhhcHApKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZmluZCBhcHAgYXQgJyR7YXBwfSdgKTtcbiAgfVxuICBsb2cuZGVidWcoJ0FwcCBpcyBwcmVzZW50Jyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERyaXZlckluZm8gKCkge1xuICBsZXQgc3RhdCA9IGF3YWl0IGZzLnN0YXQocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJykpO1xuICBsZXQgYnVpbHQgPSBzdGF0Lm10aW1lLmdldFRpbWUoKTtcblxuICAvLyBnZXQgdGhlIHBhY2thZ2UuanNvbiBhbmQgdGhlIHZlcnNpb24gZnJvbSBpdFxuICBsZXQgcGtnID0gcmVxdWlyZShfX2ZpbGVuYW1lLmluZGV4T2YoJ2J1aWxkL2xpYi91dGlscycpICE9PSAtMSA/ICcuLi8uLi9wYWNrYWdlLmpzb24nIDogJy4uL3BhY2thZ2UuanNvbicpO1xuICBsZXQgdmVyc2lvbiA9IHBrZy52ZXJzaW9uO1xuXG4gIGxldCBpbmZvID0ge1xuICAgIGJ1aWx0LFxuICAgIHZlcnNpb24sXG4gIH07XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21tYW5kVGltZW91dHMgKHZhbHVlKSB7XG4gIC8vIFRoZSB2YWx1ZSBpcyBub3JtYWxpemVkIGFscmVhZHlcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0ge307XG4gIC8vIFVzZSBhcyBkZWZhdWx0IHRpbWVvdXQgZm9yIGFsbCBjb21tYW5kcyBpZiBhIHNpbmdsZSBpbnRlZ2VyIHZhbHVlIGlzIHByb3ZpZGVkXG4gIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgcmVzdWx0W0RFRkFVTFRfVElNRU9VVF9LRVldID0gXy50b0ludGVnZXIodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBKU09OIG9iamVjdCBoYXMgYmVlbiBwcm92aWRlZC4gTGV0J3MgcGFyc2UgaXRcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBcImNvbW1hbmRUaW1lb3V0c1wiIGNhcGFiaWxpdHkgc2hvdWxkIGJlIGEgdmFsaWQgSlNPTiBvYmplY3QuIFwiJHt2YWx1ZX1cIiB3YXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGZvciAobGV0IFtjbWQsIHRpbWVvdXRdIG9mIF8udG9QYWlycyhyZXN1bHQpKSB7XG4gICAgaWYgKCFfLmlzSW50ZWdlcih0aW1lb3V0KSB8fCB0aW1lb3V0IDw9IDApIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgdGltZW91dCBmb3IgXCIke2NtZH1cIiBzaG91bGQgYmUgYSB2YWxpZCBuYXR1cmFsIG51bWJlciBvZiBtaWxsaXNlY29uZHMuIFwiJHt0aW1lb3V0fVwiIHdhcyBnaXZlbiBpbnN0ZWFkYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9jZXNzIGlkIG9mIHRoZSBtb3N0IHJlY2VudCBydW5uaW5nIGFwcGxpY2F0aW9uXG4gKiBoYXZpbmcgdGhlIHBhcnRpY3VsYXIgY29tbWFuZCBsaW5lIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBncmVwUGF0dGVybiAtIHBncmVwLWNvbXBhdGlibGUgc2VhcmNoIHBhdHRlcm4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEVpdGhlciBhIHByb2Nlc3MgaWQgb3IgbnVsbCBpZiBubyBtYXRjaGVzIHdlcmUgZm91bmQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBpZFVzaW5nUGF0dGVybiAocGdyZXBQYXR0ZXJuKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJy1uaWYnLCBwZ3JlcFBhdHRlcm5dO1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygncGdyZXAnLCBhcmdzKTtcbiAgICBjb25zdCBwaWQgPSBwYXJzZUludChzdGRvdXQsIDEwKTtcbiAgICBpZiAoaXNOYU4ocGlkKSkge1xuICAgICAgbG9nLmRlYnVnKGBDYW5ub3QgcGFyc2UgcHJvY2VzcyBpZCBmcm9tICdwZ3JlcCAke2FyZ3Muam9pbignICcpfScgb3V0cHV0OiAke3N0ZG91dH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cGlkfWA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5kZWJ1ZyhgJ3BncmVwICR7YXJncy5qb2luKCcgJyl9JyBkaWRuJ3QgZGV0ZWN0IGFueSBtYXRjaGluZyBwcm9jZXNzZXMuIFJldHVybiBjb2RlOiAke2Vyci5jb2RlfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogS2lsbCBhIHByb2Nlc3MgaGF2aW5nIHRoZSBwYXJ0aWN1bGFyIGNvbW1hbmQgbGluZSBwYXR0ZXJuLlxuICogVGhpcyBtZXRob2QgdHJpZXMgdG8gc2VuZCBTSUdJTlQsIFNJR1RFUk0gYW5kIFNJR0tJTEwgdG8gdGhlXG4gKiBtYXRjaGVkIHByb2Nlc3NlcyBpbiB0aGlzIG9yZGVyIGlmIHRoZSBwcm9jZXNzIGlzIHN0aWxsIHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBncmVwUGF0dGVybiAtIHBncmVwLWNvbXBhdGlibGUgc2VhcmNoIHBhdHRlcm4uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGtpbGxBcHBVc2luZ1BhdHRlcm4gKHBncmVwUGF0dGVybikge1xuICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBbMiwgMTUsIDldKSB7XG4gICAgaWYgKCFhd2FpdCBnZXRQaWRVc2luZ1BhdHRlcm4ocGdyZXBQYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2AtJHtzaWduYWx9YCwgJy1pZicsIHBncmVwUGF0dGVybl07XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZGVidWcoYHBraWxsICR7YXJncy5qb2luKCcgJyl9IC0+ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGF3YWl0IEIuZGVsYXkoMTAwKTtcbiAgfVxufVxuXG4vKipcbiAqIEtpbGxzIHJ1bm5pbmcgWENUZXN0IHByb2Nlc3NlcyBmb3IgdGhlIHBhcnRpY3VsYXIgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIC0gVGhlIGRldmljZSBVRElELlxuICogQHBhcmFtIHtib29sZWFufSBpc1NpbXVsYXRvciAtIEVxdWFscyB0byB0cnVlIGlmIHRoZSBjdXJyZW50IGRldmljZSBpcyBhIFNpbXVsYXRvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gUG9zc2libGUga2V5cyBhcmU6XG4gKiAgIC0ge3N0cmluZ3xudW1iZXJ9IHdkYUxvY2FsUG9ydDogVGhlIG51bWJlciBvZiBsb2NhbCBwb3J0IFdEQSBpcyBsaXN0ZW5pbmcgb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc2V0WENUZXN0UHJvY2Vzc2VzICh1ZGlkLCBpc1NpbXVsYXRvciwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHByb2Nlc3NQYXR0ZXJucyA9IFtgeGNvZGVidWlsZC4qJHt1ZGlkfWBdO1xuICBpZiAob3B0cy53ZGFMb2NhbFBvcnQpIHtcbiAgICBwcm9jZXNzUGF0dGVybnMucHVzaChgaXByb3h5ICR7b3B0cy53ZGFMb2NhbFBvcnR9YCk7XG4gIH0gZWxzZSBpZiAoIWlzU2ltdWxhdG9yKSB7XG4gICAgcHJvY2Vzc1BhdHRlcm5zLnB1c2goYGlwcm94eS4qJHt1ZGlkfWApO1xuICB9XG4gIGlmIChpc1NpbXVsYXRvcikge1xuICAgIHByb2Nlc3NQYXR0ZXJucy5wdXNoKGAke3VkaWR9LipYQ1RSdW5uZXJgKTtcbiAgfVxuICBsb2cuZGVidWcoYEtpbGxpbmcgcnVubmluZyBwcm9jZXNzZXMgJyR7cHJvY2Vzc1BhdHRlcm5zLmpvaW4oJywgJyl9JyBmb3IgdGhlIGRldmljZSAke3VkaWR9Li4uYCk7XG4gIGZvciAoY29uc3QgcGdyZXBQYXR0ZXJuIG9mIHByb2Nlc3NQYXR0ZXJucykge1xuICAgIGF3YWl0IGtpbGxBcHBVc2luZ1BhdHRlcm4ocGdyZXBQYXR0ZXJuKTtcbiAgfVxufVxuXG5leHBvcnQgeyBkZXRlY3RVZGlkLCBnZXRBbmRDaGVja1hjb2RlVmVyc2lvbiwgZ2V0QW5kQ2hlY2tJb3NTZGtWZXJzaW9uLFxuICAgICAgICAgYWRqdXN0V0RBQXR0YWNobWVudHNQZXJtaXNzaW9ucywgY2hlY2tBcHBQcmVzZW50LCBnZXREcml2ZXJJbmZvLFxuICAgICAgICAgY2xlYXJTeXN0ZW1GaWxlcywgdHJhbnNsYXRlRGV2aWNlTmFtZSwgbm9ybWFsaXplQ29tbWFuZFRpbWVvdXRzLFxuICAgICAgICAgREVGQVVMVF9USU1FT1VUX0tFWSwgcmVzZXRYQ1Rlc3RQcm9jZXNzZXMsIGdldFBpZFVzaW5nUGF0dGVybixcbiAgICAgICAgIG1hcmtTeXN0ZW1GaWxlc0ZvckNsZWFudXAgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
