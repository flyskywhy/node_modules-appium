'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _asyncbox = require('asyncbox');

var NATIVE_WIN = "NATIVE_APP";
var WEBVIEW_WIN = "WEBVIEW";
var WEBVIEW_BASE = WEBVIEW_WIN + '_';
var WEBVIEW_REGEXP = new RegExp('@?webview_devtools_remote_(\\d+)');
var WEBVIEW_PID_REGEXP = new RegExp(WEBVIEW_BASE + '(\\d+)');
var CHROMIUM_WIN = "CHROMIUM";
var CROSSWALK_SOCKET_SUFFIX = "_devtools_remote";
var CROSSWALK_REGEXP_STRING = '(\\S*)' + CROSSWALK_SOCKET_SUFFIX;
var CROSSWALK_REGEXP = new RegExp('@' + CROSSWALK_REGEXP_STRING);
var CROSSWALK_PROCESS_REGEXP = new RegExp(WEBVIEW_BASE + CROSSWALK_REGEXP_STRING);

var helpers = {};

// This function gets a list of android system processes and returns ones
// that look like webviews, with the appropriate webview prefix and their PID.
// If we pass in a deviceSocket, we only attempt to find webviews which match
// that socket name (this is for apps which embed Chromium, which isn't the
// same as chrome-backed webviews)
// TODO: some of this function belongs in appium-adb
function webviewsFromProcs(adb, deviceSocket) {
  var webviews, out, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, webviewPid, crosswalkWebviewSocket;

  return _regeneratorRuntime.async(function webviewsFromProcs$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        webviews = [];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(adb.shell(["cat", "/proc/net/unix"]));

      case 3:
        out = context$1$0.sent;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 7;
        _iterator = _getIterator(out.split("\n"));

      case 9:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 23;
          break;
        }

        line = _step.value;

        line = line.trim();

        if (!deviceSocket) {
          context$1$0.next = 17;
          break;
        }

        if (!(line.indexOf('@' + deviceSocket) === line.length - deviceSocket.length - 1)) {
          context$1$0.next = 17;
          break;
        }

        if (!(deviceSocket === "chrome_devtools_remote")) {
          context$1$0.next = 17;
          break;
        }

        webviews.push(CHROMIUM_WIN);
        return context$1$0.abrupt('continue', 20);

      case 17:
        webviewPid = undefined;
        crosswalkWebviewSocket = undefined;

        if (webviewPid = line.match(WEBVIEW_REGEXP)) {
          // for multiple webviews a list of 'WEBVIEW_<index>' will be returned
          // where <index> is zero based (same is in selendroid)
          webviews.push('' + WEBVIEW_BASE + webviewPid[1]);
        } else if (crosswalkWebviewSocket = line.match(CROSSWALK_REGEXP)) {
          if (deviceSocket) {
            if (crosswalkWebviewSocket[0].slice(1) === deviceSocket) {
              webviews.push('' + WEBVIEW_BASE + crosswalkWebviewSocket[1]);
            }
          } else {
            webviews.push('' + WEBVIEW_BASE + crosswalkWebviewSocket[1] + CROSSWALK_SOCKET_SUFFIX);
          }
        }

      case 20:
        _iteratorNormalCompletion = true;
        context$1$0.next = 9;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        return context$1$0.abrupt('return', _lodash2['default'].uniq(webviews));

      case 38:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 25, 29, 37], [30,, 32, 36]]);
}

// Take a webview name like WEBVIEW_4296 and use 'adb shell ps' to figure out
// which app package is associated with that webview. One of the reasons we
// want to do this is to make sure we're listing webviews for the actual AUT,
// not some other running app
// TODO: this should be called procFromPid and exist in appium-adb
helpers.procFromWebview = function callee$0$0(adb, webview) {
  var processName, pid, out, pkg, lines, fullHeader, header, pidColumn, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line, entries, pidEntry;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(webview.match(WEBVIEW_PID_REGEXP) === null)) {
          context$1$0.next = 5;
          break;
        }

        processName = webview.match(CROSSWALK_PROCESS_REGEXP);

        if (!(processName === null)) {
          context$1$0.next = 4;
          break;
        }

        throw new Error('Could not find process name for webview ' + webview);

      case 4:
        return context$1$0.abrupt('return', processName[1]);

      case 5:
        pid = webview.match(/\d+$/);

        if (pid) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not find PID for webview ' + webview);

      case 8:
        pid = pid[0];
        _logger2['default'].debug(webview + ' mapped to pid ' + pid);
        _logger2['default'].debug("Getting process name for webview");
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(adb.shell("ps"));

      case 13:
        out = context$1$0.sent;
        pkg = "unknown";
        lines = out.split(/\r?\n/);
        fullHeader = lines[0].trim();
        header = fullHeader.split(/\s+/);
        pidColumn = header.indexOf('PID');
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 22;
        _iterator2 = _getIterator(lines);

      case 24:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 37;
          break;
        }

        line = _step2.value;
        entries = line.trim().split(/\s+/);
        pidEntry = entries[pidColumn];

        if (!(pidEntry === pid)) {
          context$1$0.next = 34;
          break;
        }

        pkg = _lodash2['default'].last(entries);
        _logger2['default'].debug('Parsed pid: \'' + pidEntry + '\' pkg: \'' + pkg + '\' from');
        _logger2['default'].debug('    ' + fullHeader);
        _logger2['default'].debug('    ' + line);

        return context$1$0.abrupt('break', 37);

      case 34:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 24;
        break;

      case 37:
        context$1$0.next = 43;
        break;

      case 39:
        context$1$0.prev = 39;
        context$1$0.t0 = context$1$0['catch'](22);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 43:
        context$1$0.prev = 43;
        context$1$0.prev = 44;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 46:
        context$1$0.prev = 46;

        if (!_didIteratorError2) {
          context$1$0.next = 49;
          break;
        }

        throw _iteratorError2;

      case 49:
        return context$1$0.finish(46);

      case 50:
        return context$1$0.finish(43);

      case 51:

        _logger2['default'].debug('Returning process name: \'' + pkg + '\'');
        return context$1$0.abrupt('return', pkg);

      case 53:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[22, 39, 43, 51], [44,, 46, 50]]);
};

// Get a list of available webviews by introspecting processes with adb, where
// webviews are listed. It's possible to pass in a 'deviceSocket' arg, which
// limits the webview possibilities to the one running on the Chromium devtools
// socket we're interested in (see note on webviewsFromProcs)
helpers.getWebviews = function callee$0$0(adb, deviceSocket) {
  var webviews;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug("Getting a list of available webviews");
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(webviewsFromProcs(adb, deviceSocket));

      case 3:
        webviews = context$1$0.sent;

        if (!deviceSocket) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', webviews);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _asyncbox.asyncmap)(webviews, function callee$1$0(webviewName) {
          var pkg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(helpers.procFromWebview(adb, webviewName));

              case 2:
                pkg = context$2$0.sent;
                return context$2$0.abrupt('return', WEBVIEW_BASE + pkg);

              case 4:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 8:
        webviews = context$1$0.sent;

        _logger2['default'].debug('Found webviews: ' + JSON.stringify(webviews));
        return context$1$0.abrupt('return', webviews);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.decorateChromeOptions = function (caps, opts, deviceId) {
  // add options from appium session caps
  if (opts.chromeOptions) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].pairs(opts.chromeOptions)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var opt = _step3$value[0];
        var val = _step3$value[1];

        if (_lodash2['default'].isUndefined(caps.chromeOptions[opt])) {
          caps.chromeOptions[opt] = val;
        } else {
          _logger2['default'].warn('Cannot pass option ' + caps.chromeOptions[opt] + ' because ' + "Appium needs it to make chromeDriver work");
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  // add device id from adb
  caps.chromeOptions.androidDeviceSerial = deviceId;
  return caps;
};

exports['default'] = helpers;
exports.helpers = helpers;
exports.NATIVE_WIN = NATIVE_WIN;
exports.WEBVIEW_WIN = WEBVIEW_WIN;
exports.WEBVIEW_BASE = WEBVIEW_BASE;
exports.CHROMIUM_WIN = CHROMIUM_WIN;

// webview_devtools_remote_4296 => 4296

/* Output of ps is like:
 USER       PID  PPID  VSIZE  RSS   WCHAN    PC         NAME  _or_
 USER       PID  PPID  VSZ    RSS   WCHAN    ADDR     S NAME
 u0_a136   6248  179   946000 48144 ffffffff 4005903e R com.example.test
 u0_a136   6249  179   946000 48144 ffffffff          R com.example.test
*/
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93ZWJ2aWV3LWhlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7OztzQkFDSCxVQUFVOzs7O3dCQUNKLFVBQVU7O0FBRW5DLElBQU0sVUFBVSxHQUFHLFlBQVksQ0FBQztBQUNoQyxJQUFNLFdBQVcsR0FBRyxTQUFTLENBQUM7QUFDOUIsSUFBTSxZQUFZLEdBQU0sV0FBVyxNQUFHLENBQUM7QUFDdkMsSUFBTSxjQUFjLEdBQUcsSUFBSSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3RFLElBQU0sa0JBQWtCLEdBQUcsSUFBSSxNQUFNLENBQUksWUFBWSxZQUFTLENBQUM7QUFDL0QsSUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDO0FBQ2hDLElBQU0sdUJBQXVCLEdBQUcsa0JBQWtCLENBQUM7QUFDbkQsSUFBTSx1QkFBdUIsY0FBWSx1QkFBdUIsQUFBRSxDQUFDO0FBQ25FLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxNQUFNLE9BQUssdUJBQXVCLENBQUcsQ0FBQztBQUNuRSxJQUFNLHdCQUF3QixHQUFHLElBQUksTUFBTSxDQUFDLFlBQVksR0FBRyx1QkFBdUIsQ0FBQyxDQUFDOztBQUdwRixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7Ozs7Ozs7O0FBUWpCLFNBQWUsaUJBQWlCLENBQUUsR0FBRyxFQUFFLFlBQVk7TUFDN0MsUUFBUSxFQUNSLEdBQUcsa0ZBQ0UsSUFBSSxFQVlQLFVBQVUsRUFDVixzQkFBc0I7Ozs7O0FBZnhCLGdCQUFRLEdBQUcsRUFBRTs7eUNBQ0QsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDOzs7QUFBaEQsV0FBRzs7Ozs7aUNBQ1UsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7Ozs7Ozs7O0FBQXZCLFlBQUk7O0FBQ1gsWUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7YUFFZixZQUFZOzs7OztjQUNWLElBQUks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RyxDQUFDLENBQUMsRUFBRTtBQUMxQyxjQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUMvQixNQUFNO0FBQ0wsOEJBQU8sSUFBSSxDQUFDLHdCQUFzQixJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxpQkFDN0MsMkNBQTJDLENBQUMsQ0FBQztTQUMxRDtPQUNGOzs7Ozs7Ozs7Ozs7Ozs7R0FDRjs7O0FBR0QsTUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRyxRQUFRLENBQUM7QUFDbEQsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDOztxQkFFYSxPQUFPO1FBQ2IsT0FBTyxHQUFQLE9BQU87UUFBRSxVQUFVLEdBQVYsVUFBVTtRQUFFLFdBQVcsR0FBWCxXQUFXO1FBQUUsWUFBWSxHQUFaLFlBQVk7UUFBRSxZQUFZLEdBQVosWUFBWSIsImZpbGUiOiJsaWIvd2Vidmlldy1oZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgYXN5bmNtYXAgfSBmcm9tICdhc3luY2JveCc7XG5cbmNvbnN0IE5BVElWRV9XSU4gPSBcIk5BVElWRV9BUFBcIjtcbmNvbnN0IFdFQlZJRVdfV0lOID0gXCJXRUJWSUVXXCI7XG5jb25zdCBXRUJWSUVXX0JBU0UgPSBgJHtXRUJWSUVXX1dJTn1fYDtcbmNvbnN0IFdFQlZJRVdfUkVHRVhQID0gbmV3IFJlZ0V4cChgQD93ZWJ2aWV3X2RldnRvb2xzX3JlbW90ZV8oXFxcXGQrKWApO1xuY29uc3QgV0VCVklFV19QSURfUkVHRVhQID0gbmV3IFJlZ0V4cChgJHtXRUJWSUVXX0JBU0V9KFxcXFxkKylgKTtcbmNvbnN0IENIUk9NSVVNX1dJTiA9IFwiQ0hST01JVU1cIjtcbmNvbnN0IENST1NTV0FMS19TT0NLRVRfU1VGRklYID0gXCJfZGV2dG9vbHNfcmVtb3RlXCI7XG5jb25zdCBDUk9TU1dBTEtfUkVHRVhQX1NUUklORyA9IGAoXFxcXFMqKSR7Q1JPU1NXQUxLX1NPQ0tFVF9TVUZGSVh9YDtcbmNvbnN0IENST1NTV0FMS19SRUdFWFAgPSBuZXcgUmVnRXhwKGBAJHtDUk9TU1dBTEtfUkVHRVhQX1NUUklOR31gKTtcbmNvbnN0IENST1NTV0FMS19QUk9DRVNTX1JFR0VYUCA9IG5ldyBSZWdFeHAoV0VCVklFV19CQVNFICsgQ1JPU1NXQUxLX1JFR0VYUF9TVFJJTkcpO1xuXG5cbmxldCBoZWxwZXJzID0ge307XG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIGxpc3Qgb2YgYW5kcm9pZCBzeXN0ZW0gcHJvY2Vzc2VzIGFuZCByZXR1cm5zIG9uZXNcbi8vIHRoYXQgbG9vayBsaWtlIHdlYnZpZXdzLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSB3ZWJ2aWV3IHByZWZpeCBhbmQgdGhlaXIgUElELlxuLy8gSWYgd2UgcGFzcyBpbiBhIGRldmljZVNvY2tldCwgd2Ugb25seSBhdHRlbXB0IHRvIGZpbmQgd2Vidmlld3Mgd2hpY2ggbWF0Y2hcbi8vIHRoYXQgc29ja2V0IG5hbWUgKHRoaXMgaXMgZm9yIGFwcHMgd2hpY2ggZW1iZWQgQ2hyb21pdW0sIHdoaWNoIGlzbid0IHRoZVxuLy8gc2FtZSBhcyBjaHJvbWUtYmFja2VkIHdlYnZpZXdzKVxuLy8gVE9ETzogc29tZSBvZiB0aGlzIGZ1bmN0aW9uIGJlbG9uZ3MgaW4gYXBwaXVtLWFkYlxuYXN5bmMgZnVuY3Rpb24gd2Vidmlld3NGcm9tUHJvY3MgKGFkYiwgZGV2aWNlU29ja2V0KSB7XG4gIGxldCB3ZWJ2aWV3cyA9IFtdO1xuICBsZXQgb3V0ID0gYXdhaXQgYWRiLnNoZWxsKFtcImNhdFwiLCBcIi9wcm9jL25ldC91bml4XCJdKTtcbiAgZm9yIChsZXQgbGluZSBvZiBvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICBpZiAoZGV2aWNlU29ja2V0KSB7XG4gICAgICBpZiAobGluZS5pbmRleE9mKGBAJHtkZXZpY2VTb2NrZXR9YCkgPT09IGxpbmUubGVuZ3RoIC0gZGV2aWNlU29ja2V0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRldmljZVNvY2tldCA9PT0gXCJjaHJvbWVfZGV2dG9vbHNfcmVtb3RlXCIpIHtcbiAgICAgICAgICB3ZWJ2aWV3cy5wdXNoKENIUk9NSVVNX1dJTik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd2Vidmlld1BpZDtcbiAgICBsZXQgY3Jvc3N3YWxrV2Vidmlld1NvY2tldDtcbiAgICBpZiAoKHdlYnZpZXdQaWQgPSBsaW5lLm1hdGNoKFdFQlZJRVdfUkVHRVhQKSkpIHtcbiAgICAgIC8vIGZvciBtdWx0aXBsZSB3ZWJ2aWV3cyBhIGxpc3Qgb2YgJ1dFQlZJRVdfPGluZGV4Picgd2lsbCBiZSByZXR1cm5lZFxuICAgICAgLy8gd2hlcmUgPGluZGV4PiBpcyB6ZXJvIGJhc2VkIChzYW1lIGlzIGluIHNlbGVuZHJvaWQpXG4gICAgICB3ZWJ2aWV3cy5wdXNoKGAke1dFQlZJRVdfQkFTRX0ke3dlYnZpZXdQaWRbMV19YCk7XG4gICAgfSBlbHNlIGlmICgoY3Jvc3N3YWxrV2Vidmlld1NvY2tldCA9IGxpbmUubWF0Y2goQ1JPU1NXQUxLX1JFR0VYUCkpKSB7XG4gICAgICBpZiAoZGV2aWNlU29ja2V0KSB7XG4gICAgICAgIGlmIChjcm9zc3dhbGtXZWJ2aWV3U29ja2V0WzBdLnNsaWNlKDEpID09PSBkZXZpY2VTb2NrZXQpIHtcbiAgICAgICAgICB3ZWJ2aWV3cy5wdXNoKGAke1dFQlZJRVdfQkFTRX0ke2Nyb3Nzd2Fsa1dlYnZpZXdTb2NrZXRbMV19YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdlYnZpZXdzLnB1c2goYCR7V0VCVklFV19CQVNFfSR7Y3Jvc3N3YWxrV2Vidmlld1NvY2tldFsxXX0ke0NST1NTV0FMS19TT0NLRVRfU1VGRklYfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXy51bmlxKHdlYnZpZXdzKTtcbn1cblxuLy8gVGFrZSBhIHdlYnZpZXcgbmFtZSBsaWtlIFdFQlZJRVdfNDI5NiBhbmQgdXNlICdhZGIgc2hlbGwgcHMnIHRvIGZpZ3VyZSBvdXRcbi8vIHdoaWNoIGFwcCBwYWNrYWdlIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHdlYnZpZXcuIE9uZSBvZiB0aGUgcmVhc29ucyB3ZVxuLy8gd2FudCB0byBkbyB0aGlzIGlzIHRvIG1ha2Ugc3VyZSB3ZSdyZSBsaXN0aW5nIHdlYnZpZXdzIGZvciB0aGUgYWN0dWFsIEFVVCxcbi8vIG5vdCBzb21lIG90aGVyIHJ1bm5pbmcgYXBwXG4vLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBjYWxsZWQgcHJvY0Zyb21QaWQgYW5kIGV4aXN0IGluIGFwcGl1bS1hZGJcbmhlbHBlcnMucHJvY0Zyb21XZWJ2aWV3ID0gYXN5bmMgZnVuY3Rpb24gKGFkYiwgd2Vidmlldykge1xuICBpZiAod2Vidmlldy5tYXRjaChXRUJWSUVXX1BJRF9SRUdFWFApID09PSBudWxsKSB7XG4gICAgbGV0IHByb2Nlc3NOYW1lID0gd2Vidmlldy5tYXRjaChDUk9TU1dBTEtfUFJPQ0VTU19SRUdFWFApO1xuICAgIGlmIChwcm9jZXNzTmFtZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwcm9jZXNzIG5hbWUgZm9yIHdlYnZpZXcgJHt3ZWJ2aWV3fWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc05hbWVbMV07XG4gIH1cblxuICAvLyB3ZWJ2aWV3X2RldnRvb2xzX3JlbW90ZV80Mjk2ID0+IDQyOTZcbiAgbGV0IHBpZCA9IHdlYnZpZXcubWF0Y2goL1xcZCskLyk7XG4gIGlmICghcGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBQSUQgZm9yIHdlYnZpZXcgJHt3ZWJ2aWV3fWApO1xuICB9XG4gIHBpZCA9IHBpZFswXTtcbiAgbG9nZ2VyLmRlYnVnKGAke3dlYnZpZXd9IG1hcHBlZCB0byBwaWQgJHtwaWR9YCk7XG4gIGxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgcHJvY2VzcyBuYW1lIGZvciB3ZWJ2aWV3XCIpO1xuICBsZXQgb3V0ID0gYXdhaXQgYWRiLnNoZWxsKFwicHNcIik7XG4gIGxldCBwa2cgPSBcInVua25vd25cIjtcbiAgbGV0IGxpbmVzID0gb3V0LnNwbGl0KC9cXHI/XFxuLyk7XG5cbiAgLyogT3V0cHV0IG9mIHBzIGlzIGxpa2U6XG4gICBVU0VSICAgICAgIFBJRCAgUFBJRCAgVlNJWkUgIFJTUyAgIFdDSEFOICAgIFBDICAgICAgICAgTkFNRSAgX29yX1xuICAgVVNFUiAgICAgICBQSUQgIFBQSUQgIFZTWiAgICBSU1MgICBXQ0hBTiAgICBBRERSICAgICBTIE5BTUVcbiAgIHUwX2ExMzYgICA2MjQ4ICAxNzkgICA5NDYwMDAgNDgxNDQgZmZmZmZmZmYgNDAwNTkwM2UgUiBjb20uZXhhbXBsZS50ZXN0XG4gICB1MF9hMTM2ICAgNjI0OSAgMTc5ICAgOTQ2MDAwIDQ4MTQ0IGZmZmZmZmZmICAgICAgICAgIFIgY29tLmV4YW1wbGUudGVzdFxuICAqL1xuICBjb25zdCBmdWxsSGVhZGVyID0gbGluZXNbMF0udHJpbSgpO1xuICBjb25zdCBoZWFkZXIgPSBmdWxsSGVhZGVyLnNwbGl0KC9cXHMrLyk7XG4gIGNvbnN0IHBpZENvbHVtbiA9IGhlYWRlci5pbmRleE9mKCdQSUQnKTtcblxuICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IGxpbmUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgY29uc3QgcGlkRW50cnkgPSBlbnRyaWVzW3BpZENvbHVtbl07XG4gICAgaWYgKHBpZEVudHJ5ID09PSBwaWQpIHtcbiAgICAgIHBrZyA9IF8ubGFzdChlbnRyaWVzKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgUGFyc2VkIHBpZDogJyR7cGlkRW50cnl9JyBwa2c6ICcke3BrZ30nIGZyb21gKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgICAgICR7ZnVsbEhlYWRlcn1gKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgICAgICR7bGluZX1gKTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgbG9nZ2VyLmRlYnVnKGBSZXR1cm5pbmcgcHJvY2VzcyBuYW1lOiAnJHtwa2d9J2ApO1xuICByZXR1cm4gcGtnO1xufTtcblxuLy8gR2V0IGEgbGlzdCBvZiBhdmFpbGFibGUgd2Vidmlld3MgYnkgaW50cm9zcGVjdGluZyBwcm9jZXNzZXMgd2l0aCBhZGIsIHdoZXJlXG4vLyB3ZWJ2aWV3cyBhcmUgbGlzdGVkLiBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgaW4gYSAnZGV2aWNlU29ja2V0JyBhcmcsIHdoaWNoXG4vLyBsaW1pdHMgdGhlIHdlYnZpZXcgcG9zc2liaWxpdGllcyB0byB0aGUgb25lIHJ1bm5pbmcgb24gdGhlIENocm9taXVtIGRldnRvb2xzXG4vLyBzb2NrZXQgd2UncmUgaW50ZXJlc3RlZCBpbiAoc2VlIG5vdGUgb24gd2Vidmlld3NGcm9tUHJvY3MpXG5oZWxwZXJzLmdldFdlYnZpZXdzID0gYXN5bmMgZnVuY3Rpb24gKGFkYiwgZGV2aWNlU29ja2V0KSB7XG4gIGxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgYSBsaXN0IG9mIGF2YWlsYWJsZSB3ZWJ2aWV3c1wiKTtcbiAgbGV0IHdlYnZpZXdzID0gYXdhaXQgd2Vidmlld3NGcm9tUHJvY3MoYWRiLCBkZXZpY2VTb2NrZXQpO1xuXG4gIGlmIChkZXZpY2VTb2NrZXQpIHtcbiAgICByZXR1cm4gd2Vidmlld3M7XG4gIH1cblxuICB3ZWJ2aWV3cyA9IGF3YWl0IGFzeW5jbWFwKHdlYnZpZXdzLCBhc3luYyAod2Vidmlld05hbWUpID0+IHtcbiAgICBsZXQgcGtnID0gYXdhaXQgaGVscGVycy5wcm9jRnJvbVdlYnZpZXcoYWRiLCB3ZWJ2aWV3TmFtZSk7XG4gICAgcmV0dXJuIFdFQlZJRVdfQkFTRSArIHBrZztcbiAgfSk7XG4gIGxvZ2dlci5kZWJ1ZyhgRm91bmQgd2Vidmlld3M6ICR7SlNPTi5zdHJpbmdpZnkod2Vidmlld3MpfWApO1xuICByZXR1cm4gd2Vidmlld3M7XG59O1xuXG5oZWxwZXJzLmRlY29yYXRlQ2hyb21lT3B0aW9ucyA9IGZ1bmN0aW9uIChjYXBzLCBvcHRzLCBkZXZpY2VJZCkge1xuICAvLyBhZGQgb3B0aW9ucyBmcm9tIGFwcGl1bSBzZXNzaW9uIGNhcHNcbiAgaWYgKG9wdHMuY2hyb21lT3B0aW9ucykge1xuICAgIGZvciAobGV0IFtvcHQsIHZhbF0gb2YgXy5wYWlycyhvcHRzLmNocm9tZU9wdGlvbnMpKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChjYXBzLmNocm9tZU9wdGlvbnNbb3B0XSkpIHtcbiAgICAgICAgY2Fwcy5jaHJvbWVPcHRpb25zW29wdF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgQ2Fubm90IHBhc3Mgb3B0aW9uICR7Y2Fwcy5jaHJvbWVPcHRpb25zW29wdF19IGJlY2F1c2UgYCArXG4gICAgICAgICAgICAgICAgICAgIFwiQXBwaXVtIG5lZWRzIGl0IHRvIG1ha2UgY2hyb21lRHJpdmVyIHdvcmtcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGRldmljZSBpZCBmcm9tIGFkYlxuICBjYXBzLmNocm9tZU9wdGlvbnMuYW5kcm9pZERldmljZVNlcmlhbCA9IGRldmljZUlkO1xuICByZXR1cm4gY2Fwcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhlbHBlcnM7XG5leHBvcnQgeyBoZWxwZXJzLCBOQVRJVkVfV0lOLCBXRUJWSUVXX1dJTiwgV0VCVklFV19CQVNFLCBDSFJPTUlVTV9XSU4gfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
